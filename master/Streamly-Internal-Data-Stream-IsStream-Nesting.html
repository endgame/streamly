<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Stream.IsStream.Nesting</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2017 Composewell Technologies</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.IsStream.Nesting</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Generate</a><ul><li><a href="#g:2">Combine Two Streams</a><ul><li><a href="#g:3">Appending</a></li><li><a href="#g:4">Interleaving</a></li><li><a href="#g:5">Scheduling</a></li><li><a href="#g:6">Parallel</a></li><li><a href="#g:7">Zipping</a></li><li><a href="#g:8">Merging</a></li><li><a href="#g:9">Trimming</a></li></ul></li><li><a href="#g:10">Combine N Streams</a><ul><li><a href="#g:11">Flatten Containers of Streams</a></li><li><a href="#g:12">ConcatMap</a></li><li><a href="#g:13">ConcatUnfold</a></li><li><a href="#g:14">Interpose</a></li><li><a href="#g:15">Intercalate</a></li><li><a href="#g:16">IterateMap</a></li></ul></li></ul></li><li><a href="#g:17">Eliminate</a><ul><li><a href="#g:18">Folding</a></li><li><a href="#g:19">Parsing</a></li><li><a href="#g:20">Chunking</a></li><li><a href="#g:21">Grouping</a></li><li><a href="#g:22">Splitting</a></li><li><a href="#g:23">Windowed Classification</a><ul><li><a href="#g:24">Tumbling Windows</a></li><li><a href="#g:25">Keep Alive Windows</a></li></ul></li></ul></li><li><a href="#g:26">Transform (Nested Containers)</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Transformations involving multiple streams, streams and unfolds or streams
 and folds.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:serial">serial</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:append">append</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleave">interleave</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveMin">interleaveMin</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveSuffix">interleaveSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveInfix">interleaveInfix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:wSerial">wSerial</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:wSerialFst">wSerialFst</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:wSerialMin">wSerialMin</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:ahead">ahead</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:async">async</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:wAsync">wAsync</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:roundrobin">roundrobin</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:parallel">parallel</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:parallelFst">parallelFst</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:parallelMin">parallelMin</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:zipWith">zipWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipWithM">zipWithM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipAsyncWith">zipAsyncWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipAsyncWithM">zipAsyncWithM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:mergeBy">mergeBy</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeByM">mergeByM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeAsyncBy">mergeAsyncBy</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeAsyncByM">mergeAsyncByM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropPrefix">dropPrefix</a> :: t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropInfix">dropInfix</a> :: t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropSuffix">dropSuffix</a> :: t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:concatM">concatM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m (t m a) -&gt; t m a</li><li class="src short"><a href="#v:concat">concat</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m (t m a) -&gt; t m a</li><li class="src short"><a href="#v:concatFoldableWith">concatFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; f (t m a) -&gt; t m a</li><li class="src short"><a href="#v:concatMapFoldableWith">concatMapFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; f a -&gt; t m b</li><li class="src short"><a href="#v:concatForFoldableWith">concatForFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; f a -&gt; (a -&gt; t m b) -&gt; t m b</li><li class="src short"><a href="#v:concatMap">concatMap</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatMapM">concatMapM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatMapWith">concatMapWith</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatSmapMWith">concatSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (s -&gt; a -&gt; m (s, t m b)) -&gt; m s -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatUnfold">concatUnfold</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatUnfoldInterleave">concatUnfoldInterleave</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatUnfoldRoundrobin">concatUnfoldRoundrobin</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:interpose">interpose</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:interposeSuffix">interposeSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:intercalate">intercalate</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:intercalateSuffix">intercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:gintercalate">gintercalate</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:gintercalateSuffix">gintercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:iterateMapWith">iterateMapWith</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (a -&gt; t m a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:iterateSmapMWith">iterateSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (b -&gt; a -&gt; m (b, t m a)) -&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:iterateMapLeftsWith">iterateMapLeftsWith</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; (t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; (a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)</li><li class="src short"><a href="#v:foldMany">foldMany</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldSequence">foldSequence</a> :: t m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldIterate">foldIterate</a> :: (b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseMany">parseMany</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseManyD">parseManyD</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserD-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserD.Types">Parser</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseManyTill">parseManyTill</a> :: <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a x -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseSequence">parseSequence</a> :: t m (<a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseIterate">parseIterate</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; (b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:chunksOf">chunksOf</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:chunksOf2">chunksOf2</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m c a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:arraysOf">arraysOf</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a)</li><li class="src short"><a href="#v:intervalsOf">intervalsOf</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:groups">groups</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:groupsBy">groupsBy</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:groupsByRolling">groupsByRolling</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOn">splitOn</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSuffix">splitOnSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitWithSuffix">splitWithSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:wordsBy">wordsBy</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitBySeq">splitBySeq</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSeq">splitOnSeq</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSuffixSeq">splitOnSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitWithSuffixSeq">splitWithSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:classifySessionsBy">classifySessionsBy</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>) -&gt; t m (k, b)</li><li class="src short"><a href="#v:classifySessionsOf">classifySessionsOf</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>) -&gt; t m (k, b)</li><li class="src short"><a href="#v:classifyKeepAliveSessions">classifyKeepAliveSessions</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>) -&gt; t m (k, b)</li><li class="src short"><a href="#v:splitInnerBy">splitInnerBy</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a)</li><li class="src short"><a href="#v:splitInnerBySuffix">splitInnerBySuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (f a), <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (f a)) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Generate</h1></a><div class="doc"><p>Combining streams to generate streams.</p></div><a href="#g:2" id="g:2"><h2>Combine Two Streams</h2></a><div class="doc"><p>Functions ending in the shape:</p><p><code>t m a -&gt; t m a -&gt; t m a</code>.</p></div><a href="#g:3" id="g:3"><h3>Appending</h3></a><div class="top"><p class="src"><a id="v:serial" class="def">serial</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#serial" class="link">Source</a> <a href="#v:serial" class="selflink">#</a></p><div class="doc"><p>Polymorphic version of the <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation <code><a href="Streamly.html#v:-60--62-" title="Streamly">&lt;&gt;</a></code> of <code>SerialT</code>.
 Appends two streams sequentially, yielding all elements from the first
 stream, and then all elements from the second stream.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:append" class="def">append</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#append" class="link">Source</a> <a href="#v:append" class="selflink">#</a></p><div class="doc"><p>Append the outputs of two streams, yielding all the elements from the
 first stream and then yielding all the elements from the second stream.</p><p>IMPORTANT NOTE: This could be 100x faster than <code>serial/&lt;&gt;</code> for appending a
 few (say 100) streams because it can fuse via stream fusion. However, it
 does not scale for a large number of streams (say 1000s) and becomes
 qudartically slow. Therefore use this for custom appending of a few streams
 but use <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream.Nesting">concatMap</a></code> or 'concatMapWith serial' for appending <code>n</code> streams or
 infinite containers of streams.</p><p><em>Internal</em></p></div></div><a href="#g:4" id="g:4"><h3>Interleaving</h3></a><div class="top"><p class="src"><a id="v:interleave" class="def">interleave</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#interleave" class="link">Source</a> <a href="#v:interleave" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. If any of the streams finishes
 early the other stream continues alone until it too finishes.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleave &quot;ab&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,,,&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleave &quot;abcd&quot; &quot;,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,cd&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:interleave" title="Streamly.Internal.Data.Stream.IsStream.Nesting">interleave</a></code> is dual to <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:interleaveMin" title="Streamly.Internal.Data.Stream.IsStream.Nesting">interleaveMin</a></code>, it can be called <code>interleaveMax</code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveMin" class="def">interleaveMin</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#interleaveMin" class="link">Source</a> <a href="#v:interleaveMin" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. The output stops as soon as any
 of the two streams finishes, discarding the remaining part of the other
 stream. The last element of the resulting stream would be from the longer
 stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveMin &quot;ab&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveMin &quot;abcd&quot; &quot;,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,c&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:interleaveMin" title="Streamly.Internal.Data.Stream.IsStream.Nesting">interleaveMin</a></code> is dual to <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:interleave" title="Streamly.Internal.Data.Stream.IsStream.Nesting">interleave</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveSuffix" class="def">interleaveSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#interleaveSuffix" class="link">Source</a> <a href="#v:interleaveSuffix" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. As soon as the first stream
 finishes, the output stops, discarding the remaining part of the second
 stream. In this case, the last element in the resulting stream would be from
 the second stream. If the second stream finishes early then the first stream
 still continues to yield elements until it finishes.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveSuffix &quot;abc&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,c,&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveSuffix &quot;abc&quot; &quot;,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,bc&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:interleaveSuffix" title="Streamly.Internal.Data.Stream.IsStream.Nesting">interleaveSuffix</a></code> is a dual of <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:interleaveInfix" title="Streamly.Internal.Data.Stream.IsStream.Nesting">interleaveInfix</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveInfix" class="def">interleaveInfix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#interleaveInfix" class="link">Source</a> <a href="#v:interleaveInfix" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream and ending at the first stream.
 If the second stream is longer than the first, elements from the second
 stream are infixed with elements from the first stream. If the first stream
 is longer then it continues yielding elements even after the second stream
 has finished.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveInfix &quot;abc&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,c&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveInfix &quot;abc&quot; &quot;,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,bc&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:interleaveInfix" title="Streamly.Internal.Data.Stream.IsStream.Nesting">interleaveInfix</a></code> is a dual of <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:interleaveSuffix" title="Streamly.Internal.Data.Stream.IsStream.Nesting">interleaveSuffix</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:wSerial" class="def">wSerial</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#wSerial" class="link">Source</a> <a href="#v:wSerial" class="selflink">#</a></p><div class="doc"><p>Polymorphic version of the <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation <code><a href="Streamly.html#v:-60--62-" title="Streamly">&lt;&gt;</a></code> of <code><a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a></code>.
 Interleaves two streams, yielding one element from each stream alternately.
 When one stream stops the rest of the other stream is used in the output
 stream.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:wSerialFst" class="def">wSerialFst</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Serial.html#wSerialFst" class="link">Source</a> <a href="#v:wSerialFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:wSerial" title="Streamly.Internal.Data.Stream.IsStream.Nesting">wSerial</a></code> but stops interleaving as soon as the first stream stops.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:wSerialMin" class="def">wSerialMin</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Serial.html#wSerialMin" class="link">Source</a> <a href="#v:wSerialMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:wSerial" title="Streamly.Internal.Data.Stream.IsStream.Nesting">wSerial</a></code> but stops interleaving as soon as any of the two streams
 stops.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:5" id="g:5"><h3>Scheduling</h3></a><div class="top"><p class="src"><a id="v:ahead" class="def">ahead</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#ahead" class="link">Source</a> <a href="#v:ahead" class="selflink">#</a></p><div class="doc"><p>Polymorphic version of the <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation <code><a href="Streamly.html#v:-60--62-" title="Streamly">&lt;&gt;</a></code> of <code><a href="Streamly-Internal-Data-Stream-Ahead.html#t:AheadT" title="Streamly.Internal.Data.Stream.Ahead">AheadT</a></code>.
 Merges two streams sequentially but with concurrent lookahead.</p><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:async" class="def">async</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.Async.html#async" class="link">Source</a> <a href="#v:async" class="selflink">#</a></p><div class="doc"><p>Polymorphic version of the <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation <code><a href="Streamly.html#v:-60--62-" title="Streamly">&lt;&gt;</a></code> of <code><a href="Streamly-Internal-Data-Stream-Async.html#t:AsyncT" title="Streamly.Internal.Data.Stream.Async">AsyncT</a></code>.
 Merges two streams possibly concurrently, preferring the
 elements from the left one when available.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:wAsync" class="def">wAsync</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.Async.html#wAsync" class="link">Source</a> <a href="#v:wAsync" class="selflink">#</a></p><div class="doc"><p>Polymorphic version of the <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation <code><a href="Streamly.html#v:-60--62-" title="Streamly">&lt;&gt;</a></code> of <code><a href="Streamly-Internal-Data-Stream-Async.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.Async">WAsyncT</a></code>.
 Merges two streams concurrently choosing elements from both fairly.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:roundrobin" class="def">roundrobin</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#roundrobin" class="link">Source</a> <a href="#v:roundrobin" class="selflink">#</a></p><div class="doc"><p>Schedule the execution of two streams in a fair round-robin manner,
 executing each stream once, alternately. Execution of a stream may not
 necessarily result in an output, a stream may chose to <code>Skip</code> producing an
 element until later giving the other stream a chance to run. Therefore, this
 combinator fairly interleaves the execution of two streams rather than
 fairly interleaving the output of the two streams. This can be useful in
 co-operative multitasking without using explicit threads. This can be used
 as an alternative to <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Nesting">async</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Internal</em></p></div></div><a href="#g:6" id="g:6"><h3>Parallel</h3></a><div class="top"><p class="src"><a id="v:parallel" class="def">parallel</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#parallel" class="link">Source</a> <a href="#v:parallel" class="selflink">#</a></p><div class="doc"><p>Execute two streams concurrently and merge their outputs.  For example, if
 stream <code>a</code> is a serial stream consisting of <code>a1, a2, a3</code> and stream <code>b</code> is a
 serial stream consisting of <code>b1, b2, b3</code> then stream <code>a <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream.Nesting">parallel</a></code> b</code> may
 produce <code>a1, b1, a2, b2, a3, b3</code> or <code>a1, a2, b1, a3, b2, b3</code> or some other
 combination depending on the rate at which the two streams produce elements.
 However, the relative order of outputs from a single stream e.g. <code>a1, a2,
 a3</code> would remain the same in the resulting stream. The effects in the two
 streams may occur concurrently.</p><p>To run single actions (instead of streams) in parallel wrap them into
 singleton streams.  The following trivial example is semantically equivalent
 to running the action <code>putStrLn &quot;hello&quot;</code> in the current thread:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.yieldM (putStrLn &quot;hello&quot;) `parallel` S.nil
</code></strong>&gt; hello
&gt; [()]
</pre><p>Run two actions concurrently:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.yieldM (putStrLn &quot;hello&quot;) `parallel` S.yieldM (putStrLn &quot;world&quot;)
</code></strong>&gt; hello
&gt; world
&gt; [(),()]
</pre><p>Run effects concurrently, disregarding their outputs:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.nilM (putStrLn &quot;hello&quot;) `parallel` S.nilM (putStrLn &quot;world&quot;)
</code></strong>&gt; hello
&gt; world
&gt; []
</pre><p>Run an effectful action, and a pure effect without any output, concurrently:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.yieldM (return 1) `parallel` S.nilM (putStrLn &quot;world&quot;)
</code></strong>world
[1]
</pre><p>Note that <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream.Nesting">parallel</a></code> is a polymorphic version of the <code>Semigroup</code> operation
 <code>&lt;&gt;</code> of <code><a href="Streamly-Internal-Data-Stream-Parallel.html#t:ParallelT" title="Streamly.Internal.Data.Stream.Parallel">ParallelT</a></code>.</p><p><code>nilM</code> is currently <code>Internal</code>.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:parallelFst" class="def">parallelFst</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Parallel.html#parallelFst" class="link">Source</a> <a href="#v:parallelFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream.Nesting">parallel</a></code> but stops the output as soon as the first stream stops.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:parallelMin" class="def">parallelMin</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Parallel.html#parallelMin" class="link">Source</a> <a href="#v:parallelMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream.Nesting">parallel</a></code> but stops the output as soon as any of the two streams
 stops.</p><p><em>Internal</em></p></div></div><a href="#g:7" id="g:7"><h3>Zipping</h3></a><div class="top"><p class="src"><a id="v:zipWith" class="def">zipWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.Zip.html#zipWith" class="link">Source</a> <a href="#v:zipWith" class="selflink">#</a></p><div class="doc"><p>Zip two streams serially using a pure zipping function.</p><pre>&gt; S.toList $ S.zipWith (+) (S.fromList [1,2,3]) (S.fromList [4,5,6])
[5,7,9]
</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipWithM" class="def">zipWithM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.Zip.html#zipWithM" class="link">Source</a> <a href="#v:zipWithM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:zipWith" title="Streamly.Internal.Data.Stream.IsStream.Nesting">zipWith</a></code> but using a monadic zipping function.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipAsyncWith" class="def">zipAsyncWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.Zip.html#zipAsyncWith" class="link">Source</a> <a href="#v:zipAsyncWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:zipWith" title="Streamly.Internal.Data.Stream.IsStream.Nesting">zipWith</a></code> but zips concurrently i.e. both the streams being zipped
 are generated concurrently.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipAsyncWithM" class="def">zipAsyncWithM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.Zip.html#zipAsyncWithM" class="link">Source</a> <a href="#v:zipAsyncWithM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:zipWithM" title="Streamly.Internal.Data.Stream.IsStream.Nesting">zipWithM</a></code> but zips concurrently i.e. both the streams being zipped
 are generated concurrently.</p><p><em>Since: 0.4.0</em></p></div></div><a href="#g:8" id="g:8"><h3>Merging</h3></a><div class="top"><p class="src"><a id="v:mergeBy" class="def">mergeBy</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#mergeBy" class="link">Source</a> <a href="#v:mergeBy" class="selflink">#</a></p><div class="doc"><p>Merge two streams using a comparison function. The head elements of both
 the streams are compared and the smaller of the two elements is emitted, if
 both elements are equal then the element from the first stream is used
 first.</p><p>If the streams are sorted in ascending order, the resulting stream would
 also remain sorted in ascending order.</p><pre>&gt; S.toList $ S.mergeBy compare (S.fromList [1,3,5]) (S.fromList [2,4,6,8])
[1,2,3,4,5,6,8]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeByM" class="def">mergeByM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#mergeByM" class="link">Source</a> <a href="#v:mergeByM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:mergeBy" title="Streamly.Internal.Data.Stream.IsStream.Nesting">mergeBy</a></code> but with a monadic comparison function.</p><p>Merge two streams randomly:</p><pre>&gt; randomly _ _ = randomIO &gt;&gt;= x -&gt; return $ if x then LT else GT
&gt; S.toList $ S.mergeByM randomly (S.fromList [1,1,1,1]) (S.fromList [2,2,2,2])
[2,1,2,2,2,1,1,1]
</pre><p>Merge two streams in a proportion of 2:1:</p><pre>proportionately m n = do
 ref &lt;- newIORef $ cycle $ concat [replicate m LT, replicate n GT]
 return $ \_ _ -&gt; do
     r &lt;- readIORef ref
     writeIORef ref $ tail r
     return $ head r

main = do
 f &lt;- proportionately 2 1
 xs &lt;- S.toList $ S.mergeByM f (S.fromList [1,1,1,1,1,1]) (S.fromList [2,2,2])
 print xs
</pre><pre>[1,1,2,1,1,2,1,1,2]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeAsyncBy" class="def">mergeAsyncBy</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#mergeAsyncBy" class="link">Source</a> <a href="#v:mergeAsyncBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:mergeBy" title="Streamly.Internal.Data.Stream.IsStream.Nesting">mergeBy</a></code> but merges concurrently (i.e. both the elements being
 merged are generated concurrently).</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeAsyncByM" class="def">mergeAsyncByM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#mergeAsyncByM" class="link">Source</a> <a href="#v:mergeAsyncByM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:mergeByM" title="Streamly.Internal.Data.Stream.IsStream.Nesting">mergeByM</a></code> but merges concurrently (i.e. both the elements being
 merged are generated concurrently).</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:9" id="g:9"><h3>Trimming</h3></a><div class="top"><p class="src"><a id="v:dropPrefix" class="def">dropPrefix</a> :: t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#dropPrefix" class="link">Source</a> <a href="#v:dropPrefix" class="selflink">#</a></p><div class="doc"><p>Drop prefix from the input stream if present.</p><p>Space: <code>O(1)</code></p><p><em>Unimplemented</em> - Help wanted.</p></div></div><div class="top"><p class="src"><a id="v:dropInfix" class="def">dropInfix</a> :: t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#dropInfix" class="link">Source</a> <a href="#v:dropInfix" class="selflink">#</a></p><div class="doc"><p>Drop all matching infix from the input stream if present. Infix stream
 may be consumed multiple times.</p><p>Space: <code>O(n)</code> where n is the length of the infix.</p><p><em>Unimplemented</em> - Help wanted.</p></div></div><div class="top"><p class="src"><a id="v:dropSuffix" class="def">dropSuffix</a> :: t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#dropSuffix" class="link">Source</a> <a href="#v:dropSuffix" class="selflink">#</a></p><div class="doc"><p>Drop suffix from the input stream if present. Suffix stream may be
 consumed multiple times.</p><p>Space: <code>O(n)</code> where n is the length of the suffix.</p><p><em>Unimplemented</em> - Help wanted.</p></div></div><a href="#g:10" id="g:10"><h2>Combine N Streams</h2></a><div class="doc"><p>Functions generally ending in these shapes:</p><pre>concat: f (t m a) -&gt; t m a
concatMap: (a -&gt; t m b) -&gt; t m a -&gt; t m b
concatUnfold: Unfold m a b -&gt; t m a -&gt; t m b
</pre></div><a href="#g:11" id="g:11"><h3>Flatten Containers of Streams</h3></a><div class="top"><p class="src"><a id="v:concatM" class="def">concatM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m (t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#concatM" class="link">Source</a> <a href="#v:concatM" class="selflink">#</a></p><div class="doc"><p>Given a stream value in the underlying monad, lift and join the underlying
 monad with the stream monad.</p><pre>concatM = concat . yieldM
concatM = concat . lift    -- requires <code>(MonadTrans t)</code>
concatM = join . lift      -- requires <code>(MonadTrans t</code>, <code>Monad (t m))</code>
</pre><p>See also: <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#v:concat" title="Data.Foldable">concat</a></code>, <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Traversable.html#v:sequence" title="Data.Traversable">sequence</a></code></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:concat" class="def">concat</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m (t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#concat" class="link">Source</a> <a href="#v:concat" class="selflink">#</a></p><div class="doc"><p>Flatten a stream of streams to a single stream.</p><pre>concat = concatMap id
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:concatFoldableWith" class="def">concatFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; f (t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Prelude.html#concatFoldableWith" class="link">Source</a> <a href="#v:concatFoldableWith" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#v:fold" title="Data.Foldable">fold</a></code> that allows you to fold a <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code>
 container of streams using the specified stream sum operation.</p><pre>concatFoldableWith <code>async</code> $ map return [1..3]</pre><p>Equivalent to:</p><pre>concatFoldableWith f = S.concatMapFoldableWith f id
</pre><p><em>Since: 0.8.0 (Renamed foldWith to concatFoldableWith)</em></p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><a href="#g:12" id="g:12"><h3>ConcatMap</h3></a><div class="doc"><p>Map and flatten streams.</p></div><div class="top"><p class="src"><a id="v:concatMapFoldableWith" class="def">concatMapFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; f a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.Prelude.html#concatMapFoldableWith" class="link">Source</a> <a href="#v:concatMapFoldableWith" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#v:foldMap" title="Data.Foldable">foldMap</a></code> that allows you to map a monadic streaming action
 on a <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> container and then fold it using the specified stream merge
 operation.</p><pre>concatMapFoldableWith <code>async</code> return [1..3]</pre><p>Equivalent to:</p><pre>concatMapFoldableWith f g xs = S.concatMapWith f g (S.fromFoldable xs)
</pre><p><em>Since: 0.8.0 (Renamed foldMapWith to concatMapFoldableWith)</em></p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><div class="top"><p class="src"><a id="v:concatForFoldableWith" class="def">concatForFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; f a -&gt; (a -&gt; t m b) -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.Prelude.html#concatForFoldableWith" class="link">Source</a> <a href="#v:concatForFoldableWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:concatMapFoldableWith" title="Streamly.Internal.Data.Stream.IsStream.Nesting">concatMapFoldableWith</a></code> but with the last two arguments reversed i.e. the
 monadic streaming function is the last argument.</p><p>Equivalent to:</p><pre>concatForFoldableWith = flip S.concatMapFoldableWith
</pre><p><em>Since: 0.8.0 (Renamed forEachWith to concatForFoldableWith)</em></p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><div class="top"><p class="src"><a id="v:concatMap" class="def">concatMap</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#concatMap" class="link">Source</a> <a href="#v:concatMap" class="selflink">#</a></p><div class="doc"><p>Map a stream producing function on each element of the stream and then
 flatten the results into a single stream.</p><pre>concatMap f = 'concat . map f'
concatMap = <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:concatMapWith" title="Streamly.Internal.Data.Stream.IsStream.Nesting">concatMapWith</a></code> <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:serial" title="Streamly.Internal.Data.Stream.IsStream.Nesting">serial</a></code>
concatMap f = <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:concatMapM" title="Streamly.Internal.Data.Stream.IsStream.Nesting">concatMapM</a></code> (return . f)
concatMap f = <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:concatUnfold" title="Streamly.Internal.Data.Stream.IsStream.Nesting">concatUnfold</a></code> (UF.lmap f UF.fromStream)
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatMapM" class="def">concatMapM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#concatMapM" class="link">Source</a> <a href="#v:concatMapM" class="selflink">#</a></p><div class="doc"><p>Map a stream producing monadic function on each element of the stream
 and then flatten the results into a single stream. Since the stream
 generation function is monadic, unlike <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#v:concatMap" title="Data.Foldable">concatMap</a></code>, it can produce an
 effect at the beginning of each iteration of the inner loop.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatMapWith" class="def">concatMapWith</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#concatMapWith" class="link">Source</a> <a href="#v:concatMapWith" class="selflink">#</a></p><div class="doc"><p><code>concatMapWith merge map stream</code> is a two dimensional looping combinator.
 The first argument specifies a merge or concat function that is used to
 merge the streams generated by applying the second argument i.e. the <code>map</code>
 function to each element of the input stream. The concat function could be
 <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:serial" title="Streamly.Internal.Data.Stream.IsStream.Nesting">serial</a></code>, <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream.Nesting">parallel</a></code>, <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Nesting">async</a></code>, <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:ahead" title="Streamly.Internal.Data.Stream.IsStream.Nesting">ahead</a></code> or any other zip or merge function
 and the second argument could be any stream generation function using a
 seed.</p><p><em>Compare <code>foldMapWith</code></em></p><p><em>Since: 0.7.0</em></p><p><em>Since: 0.8.0 (signature change)</em></p></div></div><div class="top"><p class="src"><a id="v:concatSmapMWith" class="def">concatSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (s -&gt; a -&gt; m (s, t m b)) -&gt; m s -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#concatSmapMWith" class="link">Source</a> <a href="#v:concatSmapMWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:concatMapWith" title="Streamly.Internal.Data.Stream.IsStream.Nesting">concatMapWith</a></code> but carries a state which can be used to share
 information across multiple steps of concat.</p><pre>concatSmapMWith combine f initial = concatMapWith combine id . smapM f initial
</pre><p><em>Internal</em></p></div></div><a href="#g:13" id="g:13"><h3>ConcatUnfold</h3></a><div class="doc"><p>Unfold and flatten streams.</p></div><div class="top"><p class="src"><a id="v:concatUnfold" class="def">concatUnfold</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#concatUnfold" class="link">Source</a> <a href="#v:concatUnfold" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream.Nesting">concatMap</a></code> but uses an <code><a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a></code> for stream generation. Unlike
 <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream.Nesting">concatMap</a></code> this can fuse the <code><a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a></code> code with the inner loop and
 therefore provide many times better performance.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatUnfoldInterleave" class="def">concatUnfoldInterleave</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#concatUnfoldInterleave" class="link">Source</a> <a href="#v:concatUnfoldInterleave" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:concatUnfold" title="Streamly.Internal.Data.Stream.IsStream.Nesting">concatUnfold</a></code> but interleaves the streams in the same way as
 <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:interleave" title="Streamly.Internal.Data.Stream.IsStream.Nesting">interleave</a></code> behaves instead of appending them.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:concatUnfoldRoundrobin" class="def">concatUnfoldRoundrobin</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#concatUnfoldRoundrobin" class="link">Source</a> <a href="#v:concatUnfoldRoundrobin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:concatUnfold" title="Streamly.Internal.Data.Stream.IsStream.Nesting">concatUnfold</a></code> but executes the streams in the same way as
 <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:roundrobin" title="Streamly.Internal.Data.Stream.IsStream.Nesting">roundrobin</a></code>.</p><p><em>Internal</em></p></div></div><a href="#g:14" id="g:14"><h3>Interpose</h3></a><div class="doc"><p>Insert effects between streams. Like concatUnfold but intersperses an
 effect between the streams. A
 special case of gintercalate.</p></div><div class="top"><p class="src"><a id="v:interpose" class="def">interpose</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#interpose" class="link">Source</a> <a href="#v:interpose" class="selflink">#</a></p><div class="doc"><p>Unfold the elements of a stream, intersperse the given element between the
 unfolded streams and then concat them into a single stream.</p><pre>unwords = S.interpose ' '</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interposeSuffix" class="def">interposeSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#interposeSuffix" class="link">Source</a> <a href="#v:interposeSuffix" class="selflink">#</a></p><div class="doc"><p>Unfold the elements of a stream, append the given element after each
 unfolded stream and then concat them into a single stream.</p><pre>unlines = S.interposeSuffix '\n'</pre><p><em>Internal</em></p></div></div><a href="#g:15" id="g:15"><h3>Intercalate</h3></a><div class="doc"><p>Insert Streams between Streams.
 Like concatUnfold but intersperses streams from another source between
 the streams from the first source.</p></div><div class="top"><p class="src"><a id="v:intercalate" class="def">intercalate</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#intercalate" class="link">Source</a> <a href="#v:intercalate" class="selflink">#</a></p><div class="doc"><p><code>intersperse</code> followed by unfold and concat.</p><pre>unwords = intercalate &quot; &quot; UF.fromList</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>intercalate &quot; &quot; UF.fromList [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]
</code></strong>&gt; &quot;abc def ghi&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:intercalateSuffix" class="def">intercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#intercalateSuffix" class="link">Source</a> <a href="#v:intercalateSuffix" class="selflink">#</a></p><div class="doc"><p><code>intersperseSuffix</code> followed by unfold and concat.</p><pre>unlines = intercalateSuffix &quot;\n&quot; UF.fromList</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>intercalate &quot;\n&quot; UF.fromList [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]
</code></strong>&gt; &quot;abc\ndef\nghi\n&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:gintercalate" class="def">gintercalate</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#gintercalate" class="link">Source</a> <a href="#v:gintercalate" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:interleaveInfix" title="Streamly.Internal.Data.Stream.IsStream.Nesting">interleaveInfix</a></code> followed by unfold and concat.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:gintercalateSuffix" class="def">gintercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#gintercalateSuffix" class="link">Source</a> <a href="#v:gintercalateSuffix" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:interleaveSuffix" title="Streamly.Internal.Data.Stream.IsStream.Nesting">interleaveSuffix</a></code> followed by unfold and concat.</p><p><em>Internal</em></p></div></div><a href="#g:16" id="g:16"><h3>IterateMap</h3></a><div class="doc"><p>Map and flatten Trees of Streams</p></div><div class="top"><p class="src"><a id="v:iterateMapWith" class="def">iterateMapWith</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (a -&gt; t m a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#iterateMapWith" class="link">Source</a> <a href="#v:iterateMapWith" class="selflink">#</a></p><div class="doc"><p>Like <code>iterateM</code> but iterates after mapping a stream generator on the
 output.</p><p>Yield an input element in the output stream, map a stream generator on it
 and then do the same on the resulting stream. This can be used for a depth
 first traversal of a tree like structure.</p><p>Note that <code>iterateM</code> is a special case of <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:iterateMapWith" title="Streamly.Internal.Data.Stream.IsStream.Nesting">iterateMapWith</a></code>:</p><pre>iterateM f = iterateMapWith serial (yieldM . f) . yieldM
</pre><p>It can be used to traverse a tree structure.  For example, to list a
 directory tree:</p><pre>Stream.iterateMapWith Stream.serial
    (either Dir.toEither (const nil))
    (yield (Left &quot;tmp&quot;))
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:iterateSmapMWith" class="def">iterateSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (b -&gt; a -&gt; m (b, t m a)) -&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#iterateSmapMWith" class="link">Source</a> <a href="#v:iterateSmapMWith" class="selflink">#</a></p><div class="doc"><p>Like <code>iterateMap</code> but carries a state in the stream generation function.
 This can be used to traverse graph like structures, we can remember the
 visited nodes in the state to avoid cycles.</p><p>Note that a combination of <code>iterateMap</code> and <code>usingState</code> can also be used to
 traverse graphs. However, this function provides a more localized state
 instead of using a global state.</p><p>See also: <code>mfix</code></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:iterateMapLeftsWith" class="def">iterateMapLeftsWith</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; (t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; (a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#iterateMapLeftsWith" class="link">Source</a> <a href="#v:iterateMapLeftsWith" class="selflink">#</a></p><div class="doc"><p>In an <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> stream iterate on <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code>s.  This is a special case of
 <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:iterateMapWith" title="Streamly.Internal.Data.Stream.IsStream.Nesting">iterateMapWith</a></code>:</p><pre>iterateMapLeftsWith combine f = iterateMapWith combine (either f (const nil))
</pre><p>To traverse a directory tree:</p><pre>iterateMapLeftsWith serial Dir.toEither (yield (Left &quot;tmp&quot;))
</pre><p><em>Internal</em></p></div></div><a href="#g:17" id="g:17"><h1>Eliminate</h1></a><div class="doc"><p>Folding and Parsing chunks of streams to eliminate nested streams.
 Functions generally ending in these shapes:</p><pre>f (Fold m a b) -&gt; t m a -&gt; t m b
f (Parser m a b) -&gt; t m a -&gt; t m b
</pre></div><a href="#g:18" id="g:18"><h2>Folding</h2></a><div class="doc"><p>Apply folds on a stream.</p></div><div class="top"><p class="src"><a id="v:foldMany" class="def">foldMany</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#foldMany" class="link">Source</a> <a href="#v:foldMany" class="selflink">#</a></p><div class="doc"><p>Apply a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> repeatedly on a stream and emit the parsed values in the
 output stream.</p><p>This is the streaming dual of the <code><a href="Streamly-Internal-Data-Fold.html#v:many" title="Streamly.Internal.Data.Fold">many</a></code>
 parse combinator.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>f = Fold.takeLE 2 Fold.sum
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.foldMany f $ Stream.fromList [1..10]
</code></strong>&gt; [3,7,11,15,19]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>f = Fold.sliceEndWith Fold.toList
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.foldMany f $ Stream.fromList &quot;hello\nworld&quot;
</code></strong>&gt; [&quot;hello\n&quot;,&quot;world&quot;]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:foldSequence" class="def">foldSequence</a> :: t m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#foldSequence" class="link">Source</a> <a href="#v:foldSequence" class="selflink">#</a></p><div class="doc"><p>Apply a stream of folds to an input stream and emit the results in the
 output stream.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:foldIterate" class="def">foldIterate</a> :: (b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#foldIterate" class="link">Source</a> <a href="#v:foldIterate" class="selflink">#</a></p><div class="doc"><p>Iterate a fold generator on a stream. The initial value <code>b</code> is used to
 generate the first fold, the fold is applied on the stream and the result of
 the fold is used to generate the next fold and so on.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>f x = Fold.takeLE 2 (Fold.mconcatTo x)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s = Stream.map Sum $ Stream.fromList [1..10]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.map getSum $ Stream.foldIterate f 0 s
</code></strong>&gt; [3,10,21,36,55,55]
</pre><p>This is the streaming equivalent of monad like sequenced application of
 folds where next fold is dependent on the previous fold.</p><p><em>Internal</em></p></div></div><a href="#g:19" id="g:19"><h2>Parsing</h2></a><div class="doc"><p>Apply parsers on a stream.</p></div><div class="top"><p class="src"><a id="v:parseMany" class="def">parseMany</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#parseMany" class="link">Source</a> <a href="#v:parseMany" class="selflink">#</a></p><div class="doc"><p>Apply a <code><a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a></code> repeatedly on a stream and emit the parsed values in the
 output stream.</p><p>This is the streaming equivalent of the <code><a href="Streamly-Internal-Data-Parser.html#v:many" title="Streamly.Internal.Data.Parser">many</a></code>
 parse combinator.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.parseMany (PR.take 2 $ PR.fromFold FL.sum) $ S.fromList [1..10]
</code></strong>&gt; [3,7,11,15,19]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.parseMany (PR.line FL.toList) $ S.fromList &quot;hello\nworld&quot;
</code></strong>&gt; [&quot;hello\n&quot;,&quot;world&quot;]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:parseManyD" class="def">parseManyD</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserD-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserD.Types">Parser</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#parseManyD" class="link">Source</a> <a href="#v:parseManyD" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:parseManyTill" class="def">parseManyTill</a> :: <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a x -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#parseManyTill" class="link">Source</a> <a href="#v:parseManyTill" class="selflink">#</a></p><div class="doc"><p><code>parseManyTill collect test stream</code> tries the parser <code>test</code> on the input,
 if <code>test</code> fails it backtracks and tries <code>collect</code>, after <code>collect</code> succeeds
 <code>test</code> is tried again and so on. The parser stops when <code>test</code> succeeds.  The
 output of <code>test</code> is discarded and the output of <code>collect</code> is emitted in the
 output stream. The parser fails if <code>collect</code> fails.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:parseSequence" class="def">parseSequence</a> :: t m (<a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#parseSequence" class="link">Source</a> <a href="#v:parseSequence" class="selflink">#</a></p><div class="doc"><p>Apply a stream of parsers to an input stream and emit the results in the
 output stream.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:parseIterate" class="def">parseIterate</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; (b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#parseIterate" class="link">Source</a> <a href="#v:parseIterate" class="selflink">#</a></p><div class="doc"><p>Iterate a parser generating function on a stream. The initial value <code>b</code> is
 used to generate the first parser, the parser is applied on the stream and
 the result is used to generate the next parser and so on.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.map getSum $ S.parseIterate (\b -&gt; PR.take 2 (FL.mconcatTo b)) 0 $ S.map Sum $ S.fromList [1..10]
</code></strong>&gt; [3,10,21,36,55,55]
</pre><p>This is the streaming equivalent of monad like sequenced application of
 parsers where next parser is dependent on the previous parser.</p><p><em>Internal</em></p></div></div><a href="#g:20" id="g:20"><h2>Chunking</h2></a><div class="doc"><p>Element unaware grouping.</p></div><div class="top"><p class="src"><a id="v:chunksOf" class="def">chunksOf</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#chunksOf" class="link">Source</a> <a href="#v:chunksOf" class="selflink">#</a></p><div class="doc"><p>Group the input stream into groups of <code>n</code> elements each and then fold each
 group using the provided fold function.</p><pre>&gt; S.toList $ S.chunksOf 2 FL.sum (S.enumerateFromTo 1 10)
 [3,7,11,15,19]</pre><p>This can be considered as an n-fold version of <code>takeLE</code> where we apply
 <code>takeLE</code> repeatedly on the leftover stream until the stream exhausts.</p><pre>chunksOf n f = foldMany (FL.takeLE n f)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:chunksOf2" class="def">chunksOf2</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m c a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#chunksOf2" class="link">Source</a> <a href="#v:chunksOf2" class="selflink">#</a></p><div class="doc"><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:arraysOf" class="def">arraysOf</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#arraysOf" class="link">Source</a> <a href="#v:arraysOf" class="selflink">#</a></p><div class="doc"><p><code>arraysOf n stream</code> groups the elements in the input stream into arrays of
 <code>n</code> elements each.</p><p>Same as the following but may be more efficient:</p><pre>arraysOf n = Stream.foldMany (A.writeN n)</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:intervalsOf" class="def">intervalsOf</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#intervalsOf" class="link">Source</a> <a href="#v:intervalsOf" class="selflink">#</a></p><div class="doc"><p>Group the input stream into windows of <code>n</code> second each and then fold each
 group using the provided fold function.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:21" id="g:21"><h2>Grouping</h2></a><div class="top"><p class="src"><a id="v:groups" class="def">groups</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#groups" class="link">Source</a> <a href="#v:groups" class="selflink">#</a></p><div class="doc"><pre>groups = groupsBy (==)
groups = groupsByRolling (==)</pre><p>Groups contiguous spans of equal elements together in individual groups.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.groups FL.toList $ S.fromList [1,1,2,2]
</code></strong>&gt; [[1,1],[2,2]]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:groupsBy" class="def">groupsBy</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#groupsBy" class="link">Source</a> <a href="#v:groupsBy" class="selflink">#</a></p><div class="doc"><p><code>groupsBy cmp f $ S.fromList [a,b,c,...]</code> assigns the element <code>a</code> to the
 first group, if <code>b `cmp` a</code> is <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>b</code> is also assigned to the same
 group.  If <code>c `cmp` a</code> is <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>c</code> is also assigned to the same
 group and so on. When the comparison fails a new group is started. Each
 group is folded using the fold <code>f</code> and the result of the fold is emitted in
 the output stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.groupsBy (&gt;) FL.toList $ S.fromList [1,3,7,0,2,5]
</code></strong>&gt; [[1,3,7],[0,2,5]]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:groupsByRolling" class="def">groupsByRolling</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#groupsByRolling" class="link">Source</a> <a href="#v:groupsByRolling" class="selflink">#</a></p><div class="doc"><p>Unlike <code>groupsBy</code> this function performs a rolling comparison of two
 successive elements in the input stream. <code>groupsByRolling cmp f $ S.fromList
 [a,b,c,...]</code> assigns the element <code>a</code> to the first group, if <code>a `cmp` b</code> is
 <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>b</code> is also assigned to the same group.  If <code>b `cmp` c</code> is
 <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>c</code> is also assigned to the same group and so on. When the
 comparison fails a new group is started. Each group is folded using the fold
 <code>f</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.groupsByRolling (\a b -&gt; a + 1 == b) FL.toList $ S.fromList [1,2,3,7,8,9]
</code></strong>&gt; [[1,2,3],[7,8,9]]
</pre><p><em>Since: 0.7.0</em></p></div></div><a href="#g:22" id="g:22"><h2>Splitting</h2></a><div class="doc"><p>Streams can be sliced into segments in space or in time. We use the
 term <code>chunk</code> to refer to a spatial length of the stream (spatial window)
 and the term <code>session</code> to refer to a length in time (time window).</p></div><div class="top"><p class="src"><a id="v:splitOn" class="def">splitOn</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#splitOn" class="link">Source</a> <a href="#v:splitOn" class="selflink">#</a></p><div class="doc"><p>Split on an infixed separator element, dropping the separator. Splits the
 stream on separator elements determined by the supplied predicate, separator
 is considered as infixed between two segments, if one side of the separator
 is missing then it is parsed as an empty stream.  The supplied <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> is
 applied on the split segments. With <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#v:-45-" title="Prelude">-</a></code> representing non-separator elements
 and <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as separator, <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:splitOn" title="Streamly.Internal.Data.Stream.IsStream.Nesting">splitOn</a></code> splits as follows:</p><pre>&quot;--.--&quot; =&gt; &quot;--&quot; &quot;--&quot;
&quot;--.&quot;   =&gt; &quot;--&quot; &quot;&quot;
&quot;.--&quot;   =&gt; &quot;&quot;   &quot;--&quot;
</pre><p><code>splitOn (== x)</code> is an inverse of <code>intercalate (S.yield x)</code></p><p>Let's use the following definition for illustration:</p><pre>splitOn' p xs = S.toList $ S.splitOn p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.&quot;
</code></strong>[&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.a&quot;
</code></strong>&gt; [&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a..b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;,&quot;b&quot;]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSuffix" class="def">splitOnSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#splitOnSuffix" class="link">Source</a> <a href="#v:splitOnSuffix" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:splitOn" title="Streamly.Internal.Data.Stream.IsStream.Nesting">splitOn</a></code> but the separator is considered as suffixed to the segments
 in the stream. A missing suffix at the end is allowed. A separator at the
 beginning is parsed as empty segment.  With <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#v:-45-" title="Prelude">-</a></code> representing elements and
 <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as separator, <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:splitOnSuffix" title="Streamly.Internal.Data.Stream.IsStream.Nesting">splitOnSuffix</a></code> splits as follows:</p><pre> &quot;--.--.&quot; =&gt; &quot;--&quot; &quot;--&quot;
 &quot;--.--&quot;  =&gt; &quot;--&quot; &quot;--&quot;
 &quot;.--.&quot;   =&gt; &quot;&quot; &quot;--&quot;
</pre><pre>splitOnSuffix' p xs = S.toList $ S.splitSuffixBy p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;.&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;.a&quot;
</code></strong>&gt; [&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.&quot;
</code></strong>&gt; [&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.b.&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a..b..&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;,&quot;b&quot;,&quot;&quot;]
</pre><pre>lines = splitOnSuffix (== '\n')</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitWithSuffix" class="def">splitWithSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#splitWithSuffix" class="link">Source</a> <a href="#v:splitWithSuffix" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:splitOnSuffix" title="Streamly.Internal.Data.Stream.IsStream.Nesting">splitOnSuffix</a></code> but keeps the suffix attached to the resulting
 splits.</p><pre>splitWithSuffix' p xs = S.toList $ S.splitWithSuffix p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;.&quot;
</code></strong>[&quot;.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;.a&quot;
</code></strong>&gt; [&quot;.&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.&quot;
</code></strong>&gt; [&quot;a.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.b&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.b.&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a..b..&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;.&quot;,&quot;b.&quot;,&quot;.&quot;]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:wordsBy" class="def">wordsBy</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#wordsBy" class="link">Source</a> <a href="#v:wordsBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:splitOn" title="Streamly.Internal.Data.Stream.IsStream.Nesting">splitOn</a></code> after stripping leading, trailing, and repeated separators.
 Therefore, <code>&quot;.a..b.&quot;</code> with <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as the separator would be parsed as
 <code>[&quot;a&quot;,&quot;b&quot;]</code>.  In other words, its like parsing words from whitespace
 separated text.</p><pre>wordsBy' p xs = S.toList $ S.wordsBy p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;&quot;
</code></strong>&gt; []
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;,&quot;
</code></strong>&gt; []
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;,a,,b,&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre>words = wordsBy isSpace</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitBySeq" class="def">splitBySeq</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#splitBySeq" class="link">Source</a> <a href="#v:splitBySeq" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:splitOnSeq" title="Streamly.Internal.Data.Stream.IsStream.Nesting">splitOnSeq</a></code> but splits the separator as well, as an infix token.</p><pre>splitOn'_ pat xs = S.toList $ S.splitOn' (A.fromList pat) (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;&quot;,&quot;e&quot;,&quot;&quot;,&quot;l&quot;,&quot;&quot;,&quot;l&quot;,&quot;&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;hello&quot; &quot;&quot;
</code></strong>&gt; [&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;hello&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;hello&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;x&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;h&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;h&quot;,&quot;ello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;o&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hell&quot;,&quot;o&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;e&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;e&quot;,&quot;llo&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;l&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;l&quot;,&quot;&quot;,&quot;l&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;ll&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;ll&quot;,&quot;o&quot;]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSeq" class="def">splitOnSeq</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#splitOnSeq" class="link">Source</a> <a href="#v:splitOnSeq" class="selflink">#</a></p><div class="doc"><p>Like <code>splitOn</code> but the separator is a sequence of elements instead of a
 single element.</p><p>For illustration, let's define a function that operates on pure lists:</p><pre>splitOnSeq' pat xs = S.toList $ S.splitOnSeq (A.fromList pat) (FL.toList) (S.fromList xs)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;&quot;
</code></strong>&gt; [&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;x&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;h&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;ello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;o&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hell&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;e&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;llo&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;l&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;ll&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;o&quot;]
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:splitOnSeq" title="Streamly.Internal.Data.Stream.IsStream.Nesting">splitOnSeq</a></code> is an inverse of <code>intercalate</code>. The following law always holds:</p><pre>intercalate . splitOn == id</pre><p>The following law holds when the separator is non-empty and contains none of
 the elements present in the input lists:</p><pre>splitOn . intercalate == id</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSuffixSeq" class="def">splitOnSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#splitOnSuffixSeq" class="link">Source</a> <a href="#v:splitOnSuffixSeq" class="selflink">#</a></p><div class="doc"><p>Like <code>splitSuffixBy</code> but the separator is a sequence of elements, instead
 of a predicate for a single element.</p><pre>splitOnSuffixSeq_ pat xs = S.toList $ S.splitOnSuffixSeq (A.fromList pat) (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;.&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;.a&quot;
</code></strong>&gt; [&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;a.&quot;
</code></strong>&gt; [&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;a.b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;a.b.&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;a..b..&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;,&quot;b&quot;,&quot;&quot;]
</pre><pre>lines = splitOnSuffixSeq &quot;\n&quot;</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:splitOnSuffixSeq" title="Streamly.Internal.Data.Stream.IsStream.Nesting">splitOnSuffixSeq</a></code> is an inverse of <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:intercalateSuffix" title="Streamly.Internal.Data.Stream.IsStream.Nesting">intercalateSuffix</a></code>. The following law
 always holds:</p><pre>intercalateSuffix . splitOnSuffixSeq == id</pre><p>The following law holds when the separator is non-empty and contains none of
 the elements present in the input lists:</p><pre>splitSuffixOn . intercalateSuffix == id</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitWithSuffixSeq" class="def">splitWithSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#splitWithSuffixSeq" class="link">Source</a> <a href="#v:splitWithSuffixSeq" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:splitOnSuffixSeq" title="Streamly.Internal.Data.Stream.IsStream.Nesting">splitOnSuffixSeq</a></code> but keeps the suffix intact in the splits.</p><pre>splitWithSuffixSeq'_ pat xs = S.toList $ S.splitWithSuffixSeq (A.fromList pat) (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;.&quot;
</code></strong>[&quot;.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;.a&quot;
</code></strong>&gt; [&quot;.&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;a.&quot;
</code></strong>&gt; [&quot;a.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;a.b&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;a.b.&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;a..b..&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;.&quot;,&quot;b.&quot;,&quot;.&quot;]
</pre><p><em>Internal</em></p></div></div><a href="#g:23" id="g:23"><h2>Windowed Classification</h2></a><div class="doc"><p>Split the stream into windows or chunks in space or time. Each window
 can be associated with a key, all events associated with a particular
 key in the window can be folded to a single result. The stream is split
 into windows of specified size, the window can be terminated early if
 the closing flag is specified in the input stream.</p><p>The term &quot;chunk&quot; is used for a space window and the term &quot;session&quot; is
 used for a time window.</p></div><a href="#g:24" id="g:24"><h3>Tumbling Windows</h3></a><div class="doc"><p>A new window starts after the previous window is finished.</p></div><div class="top"><p class="src"><a id="v:classifySessionsBy" class="def">classifySessionsBy</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#classifySessionsBy" class="link">Source</a> <a href="#v:classifySessionsBy" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>timer tick in seconds</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>session timeout in seconds</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></td><td class="doc"><p>reset the timeout when an event is received</p></td></tr><tr><td class="src">-&gt; (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>predicate to eject sessions based on session count</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</td><td class="doc"><p>Fold to be applied to session events</p></td></tr><tr><td class="src">-&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>)</td><td class="doc"><p>session key, data, timestamp</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc"><p>session key, fold result</p></td></tr></table></div><div class="doc"><p><code>classifySessionsBy tick timeout idle pred f stream</code> groups timestamped
 events in an input event stream into sessions based on a session key. Each
 element in the input stream is an event consisting of a triple <code>(session key,
 sesssion data, timestamp)</code>.  <code>session key</code> is a key that uniquely identifies
 the session.  All the events belonging to a session are folded using the fold
 <code>f</code> until the fold terminates or a timeout has occurred.  The session key and
 the result of the fold are emitted in the output stream when the session is
 purged.</p><p>When <code>idle</code> is <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a></code>, <code>timeout</code> is the maximum lifetime of a session in
 seconds, measured from the <code>timestamp</code> of the first event in that session.
 When <code>idle</code> is <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then the timeout is an idle timeout, it is reset after
 every event received in the session.</p><p><code>timestamp</code> in an event characterizes the time when the input event was
 generated, this is an absolute time measured from some <code>Epoch</code>.  The notion
 of current time is maintained by a monotonic event time clock using the
 timestamps seen in the input stream. The latest timestamp seen till now is
 used as the base for the current time.  When no new events are seen, a timer
 is started with a tick duration specified by <code>tick</code>. This timer is used to
 detect session timeouts in the absence of new events.</p><p>The predicate <code>pred</code> is invoked with the current session count, if it
 returns <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> a session is ejected from the session cache before inserting
 a new session. This could be useful to alert or eject sessions when the
 number of sessions becomes too high.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:classifySessionsOf" class="def">classifySessionsOf</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#classifySessionsOf" class="link">Source</a> <a href="#v:classifySessionsOf" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>time window size</p></td></tr><tr><td class="src">-&gt; (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>predicate to eject sessions on session count</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</td><td class="doc"><p>Fold to be applied to session events</p></td></tr><tr><td class="src">-&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>)</td><td class="doc"><p>session key, data, timestamp</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Split the stream into fixed size time windows of specified interval in
 seconds. Within each such window, fold the elements in sessions identified
 by the session keys. The fold result is emitted in the output stream if the
 fold returns a <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code> result or if the time window ends.</p><p>Session <code>timestamp</code> in the input stream is an absolute time from some epoch,
 characterizing the time when the input element was generated.  To detect
 session window end, a monotonic event time clock is maintained synced with
 the timestamps with a clock resolution of 1 second.</p><p>If the ejection predicate returns <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>, the session with the longest
 lifetime is ejected before inserting a new session.</p><pre>classifySessionsOf interval pred = classifySessionsBy 1 interval False pred
</pre><pre>&gt;&gt;&gt; S.mapM_ print
  $ S.classifySessionsOf 3 (const (return False)) (fmap Right FL.toList)
  $ S.map ((ts,(k,a)) -&gt; (k, a, ts))
  $ S.timestamped
  $ S.delay 1
  $ (,) <a href="$">$</a> S.fromList [1,2,3] <a href="*">*</a> S.fromList [1,2,3]
</pre><p><em>Internal</em></p></div></div><a href="#g:25" id="g:25"><h3>Keep Alive Windows</h3></a><div class="doc"><p>The window size is extended if an event arrives within the specified
 window size. This can represent sessions with idle or inactive timeout.</p></div><div class="top"><p class="src"><a id="v:classifyKeepAliveSessions" class="def">classifyKeepAliveSessions</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#classifyKeepAliveSessions" class="link">Source</a> <a href="#v:classifyKeepAliveSessions" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>session inactive timeout</p></td></tr><tr><td class="src">-&gt; (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>predicate to eject sessions on session count</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</td><td class="doc"><p>Fold to be applied to session payload data</p></td></tr><tr><td class="src">-&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>)</td><td class="doc"><p>session key, data, timestamp</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:classifySessionsOf" title="Streamly.Internal.Data.Stream.IsStream.Nesting">classifySessionsOf</a></code> but the session is kept alive if an event is
 received within the session window. The session times out and gets closed
 only if no event is received within the specified session window size.</p><p>If the ejection predicate returns <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>, the session that was idle for
 the longest time is ejected before inserting a new session.</p><pre>classifyKeepAliveSessions timeout pred = classifySessionsBy 1 timeout True pred
</pre><p><em>Internal</em></p></div></div><a href="#g:26" id="g:26"><h1>Transform (Nested Containers)</h1></a><div class="top"><p class="src"><a id="v:splitInnerBy" class="def">splitInnerBy</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#splitInnerBy" class="link">Source</a> <a href="#v:splitInnerBy" class="selflink">#</a></p><div class="doc"><p><code>splitInnerBy splitter joiner stream</code> splits the inner containers <code>f a</code> of
 an input stream <code>t m (f a)</code> using the <code>splitter</code> function. Container
 elements <code>f a</code> are collected until a split occurs, then all the elements
 before the split are joined using the <code>joiner</code> function.</p><p>For example, if we have a stream of <code>Array Word8</code>, we may want to split the
 stream into arrays representing lines separated by 'n' byte such that the
 resulting stream after a split would be one array for each line.</p><p>CAUTION! This is not a true streaming function as the container size after
 the split and merge may not be bounded.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitInnerBySuffix" class="def">splitInnerBySuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (f a), <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (f a)) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Nesting.html#splitInnerBySuffix" class="link">Source</a> <a href="#v:splitInnerBySuffix" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Nesting.html#v:splitInnerBy" title="Streamly.Internal.Data.Stream.IsStream.Nesting">splitInnerBy</a></code> but splits assuming the separator joins the segment in
 a suffix style.</p><p><em>Internal</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>