<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Stream.IsStream.Common</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2017 Composewell Technologies</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.IsStream.Common</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Generation</a></li><li><a href="#g:2">Elimination</a></li><li><a href="#g:3">Transformation</a></li><li><a href="#g:4">Nesting</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:yield">yield</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; a -&gt; t m a</li><li class="src short"><a href="#v:yieldM">yieldM</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t) =&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:repeatM">repeatM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:timesWith">timesWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>)</li><li class="src short"><a href="#v:absTimesWith">absTimesWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a></li><li class="src short"><a href="#v:relTimesWith">relTimesWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a></li><li class="src short"><a href="#v:fold">fold</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:scanlMAfter-39-">scanlMAfter'</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; (b -&gt; m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:postscanlM-39-">postscanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:smapM">smapM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (s -&gt; a -&gt; m (s, b)) -&gt; m s -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:take">take</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:drop">drop</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:findIndices">findIndices</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:intersperseM">intersperseM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:interjectSuffix">interjectSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:reverse">reverse</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:reverse-39-">reverse'</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:concatM">concatM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m (t m a) -&gt; t m a</li><li class="src short"><a href="#v:concatMapM">concatMapM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSeq">splitOnSeq</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Generation</h1></a><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><pre>yield a = a `cons` nil
</pre><p>Create a singleton stream from a pure value.</p><p>The following holds in monadic streams, but not in Zip streams:</p><pre>yield = pure
yield = yieldM . pure
</pre><p>In Zip applicative streams <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:yield" title="Streamly.Internal.Data.Stream.IsStream.Common">yield</a></code> is not the same as <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> because in that
 case <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> is equivalent to <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-List.html#v:repeat" title="GHC.List">repeat</a></code> instead. <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:yield" title="Streamly.Internal.Data.Stream.IsStream.Common">yield</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> are
 equally efficient, in other cases <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:yield" title="Streamly.Internal.Data.Stream.IsStream.Common">yield</a></code> may be slightly more efficient
 than the other equivalent definitions.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:yieldM" class="def">yieldM</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t) =&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#yieldM" class="link">Source</a> <a href="#v:yieldM" class="selflink">#</a></p><div class="doc"><pre>yieldM m = m `consM` nil
</pre><p>Create a singleton stream from a monadic action.</p><pre>&gt; toList $ yieldM getLine
hello
[&quot;hello&quot;]
</pre><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:repeatM" class="def">repeatM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#repeatM" class="link">Source</a> <a href="#v:repeatM" class="selflink">#</a></p><div class="doc"><pre>repeatM = fix . consM
repeatM = cycle1 . yieldM
</pre><p>Generate a stream by repeatedly executing a monadic action forever.</p><pre>drain $ serially $ S.take 10 $ S.repeatM $ (threadDelay 1000000 &gt;&gt; print 1)
drain $ asyncly  $ S.take 10 $ S.repeatM $ (threadDelay 1000000 &gt;&gt; print 1)
</pre><p><em>Concurrent, infinite (do not use with <code>parallely</code>)</em></p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:timesWith" class="def">timesWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>) <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#timesWith" class="link">Source</a> <a href="#v:timesWith" class="selflink">#</a></p><div class="doc"><p><code>timesWith g</code> returns a stream of time value tuples. The first component
 of the tuple is an absolute time reference (epoch) denoting the start of the
 stream and the second component is a time relative to the reference.</p><p>The argument <code>g</code> specifies the granularity of the relative time in seconds.
 A lower granularity clock gives higher precision but is more expensive in
 terms of CPU usage. Any granularity lower than 1 ms is treated as 1 ms.</p><pre>&gt;&gt;&gt; S.mapM_ (x -&gt; print x &gt;&gt; threadDelay 1000000) $ S.timesWith 0.01
&gt; (AbsTime (TimeSpec {sec = 2496295, nsec = 536223000}),RelTime64 (NanoSecond64 0))
&gt; (AbsTime (TimeSpec {sec = 2496295, nsec = 536223000}),RelTime64 (NanoSecond64 1002028000))
&gt; (AbsTime (TimeSpec {sec = 2496295, nsec = 536223000}),RelTime64 (NanoSecond64 1996656000))
</pre><p>Note: This API is not safe on 32-bit machines.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:absTimesWith" class="def">absTimesWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#absTimesWith" class="link">Source</a> <a href="#v:absTimesWith" class="selflink">#</a></p><div class="doc"><p><code>absTimesWith g</code> returns a stream of absolute timestamps using a clock of
 granularity <code>g</code> specified in seconds. A low granularity clock is more
 expensive in terms of CPU usage.  Any granularity lower than 1 ms is treated
 as 1 ms.</p><pre>&gt;&gt;&gt; S.mapM_ print $ S.delayPre 1 $ S.absTimesWith 0.01
</pre><p>Note: This API is not safe on 32-bit machines.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:relTimesWith" class="def">relTimesWith</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#relTimesWith" class="link">Source</a> <a href="#v:relTimesWith" class="selflink">#</a></p><div class="doc"><p><code>relTimesWith g</code> returns a stream of relative time values starting from 0,
 using a clock of granularity <code>g</code> specified in seconds. A low granularity
 clock is more expensive in terms of CPU usage.  Any granularity lower than 1
 ms is treated as 1 ms.</p><pre>&gt;&gt;&gt; S.mapM_ print $ S.delayPre 1 $ S.relTimesWith 0.01
&gt; RelTime64 (NanoSecond64 0)
&gt; RelTime64 (NanoSecond64 91139000)
&gt; RelTime64 (NanoSecond64 204052000)
</pre><p>Note: This API is not safe on 32-bit machines.</p><p><em>Internal</em></p></div></div><a href="#g:2" id="g:2"><h1>Elimination</h1></a><div class="top"><p class="src"><a id="v:fold" class="def">fold</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#fold" class="link">Source</a> <a href="#v:fold" class="selflink">#</a></p><div class="doc"><p>Fold a stream using the supplied left <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> and reducing the resulting
 expression strictly at each step. The behavior is similar to <code>foldl'</code>. A
 <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> can terminate early without consuming the full stream. See the
 documentation of individual <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>s for termination behavior.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.fold FL.sum (S.enumerateFromTo 1 100)
</code></strong>5050
</pre><p><em>Since: 0.7.0</em></p></div></div><a href="#g:3" id="g:3"><h1>Transformation</h1></a><div class="top"><p class="src"><a id="v:scanlMAfter-39-" class="def">scanlMAfter'</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; (b -&gt; m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#scanlMAfter%27" class="link">Source</a> <a href="#v:scanlMAfter-39-" class="selflink">#</a></p><div class="doc"><p><code>scanlMAfter' accumulate initial done stream</code> is like <code>scanlM'</code> except
 that it provides an additional <code>done</code> function to be applied on the
 accumulator when the stream stops. The result of <code>done</code> is also emitted in
 the stream.</p><p>This function can be used to allocate a resource in the beginning of the
 scan and release it when the stream ends or to flush the internal state of
 the scan at the end.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:postscanlM-39-" class="def">postscanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#postscanlM%27" class="link">Source</a> <a href="#v:postscanlM-39-" class="selflink">#</a></p><div class="doc"><p>Like <code>postscanl'</code> but with a monadic step function and a monadic seed.</p><p><em>Since: 0.7.0</em></p><p><em>Since: 0.8.0 (signature change)</em></p></div></div><div class="top"><p class="src"><a id="v:smapM" class="def">smapM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (s -&gt; a -&gt; m (s, b)) -&gt; m s -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#smapM" class="link">Source</a> <a href="#v:smapM" class="selflink">#</a></p><div class="doc"><p>A stateful <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Traversable.html#v:mapM" title="Data.Traversable">mapM</a></code>, equivalent to a left scan, more like mapAccumL.
 Hopefully, this is a better alternative to <code>scan</code>. Separation of state from
 the output makes it easier to think in terms of a shared state, and also
 makes it easier to keep the state fully strict and the output lazy.</p><p>See also: <code>scanlM'</code></p><p><em>Internal</em></p></div></div><div class="doc"><p>The stateful step function can be simplified to <code>(s -&gt; a -&gt; m b)</code> to provide
 a read-only environment. However, that would just be <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Traversable.html#v:mapM" title="Data.Traversable">mapM</a></code>.</p><p>The initial action could be <code>m (s, Maybe b)</code>, and we can also add a final
 action <code>s -&gt; m (Maybe b)</code>. This can be used to get pre/post scan like
 functionality and also to flush the state in the end like scanlMAfter'.
 We can also use it along with a fusible version of bracket to get
 scanlMAfter' like functionality. See issue #677.</p><p>This can be further generalized to a type similar to Fold/Parser, giving it
 filtering and parsing capability as well (this is in fact equivalent to
 parseMany):</p><p>smapM :: (s -&gt; a -&gt; m (Step s b)) -&gt; m s -&gt; t m a -&gt; t m b</p></div><div class="top"><p class="src"><a id="v:take" class="def">take</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#take" class="link">Source</a> <a href="#v:take" class="selflink">#</a></p><div class="doc"><p>Take first <code>n</code> elements from the stream and discard the rest.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#takeWhile" class="link">Source</a> <a href="#v:takeWhile" class="selflink">#</a></p><div class="doc"><p>End the stream as soon as the predicate fails on an element.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:drop" class="def">drop</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#drop" class="link">Source</a> <a href="#v:drop" class="selflink">#</a></p><div class="doc"><p>Discard first <code>n</code> elements from the stream and take the rest.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:findIndices" class="def">findIndices</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#findIndices" class="link">Source</a> <a href="#v:findIndices" class="selflink">#</a></p><div class="doc"><p>Find all the indices where the element in the stream satisfies the given
 predicate.</p><pre>findIndices = fold Fold.findIndices</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseM" class="def">intersperseM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#intersperseM" class="link">Source</a> <a href="#v:intersperseM" class="selflink">#</a></p><div class="doc"><p>Insert an effect and its output before consuming an element of a stream
 except the first one.</p><pre>&gt;&gt;&gt; S.toList $ S.trace putChar $ S.intersperseM (putChar <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> &gt;&gt; return ',') $ S.fromList &quot;hello&quot;
&gt; h.,e.,l.,l.,o&quot;h,e,l,l,o&quot;
</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:interjectSuffix" class="def">interjectSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#interjectSuffix" class="link">Source</a> <a href="#v:interjectSuffix" class="selflink">#</a></p><div class="doc"><p>Intersperse a monadic action into the input stream after every <code>n</code>
 seconds.</p><pre>&gt; S.drain $ S.interjectSuffix 1 (putChar ',') $ S.mapM (\x -&gt; threadDelay 1000000 &gt;&gt; putChar x) $ S.fromList &quot;hello&quot;
&quot;h,e,l,l,o&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:reverse" class="def">reverse</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#reverse" class="link">Source</a> <a href="#v:reverse" class="selflink">#</a></p><div class="doc"><p>Returns the elements of the stream in reverse order.  The stream must be
 finite. Note that this necessarily buffers the entire stream in memory.</p><p><em>Since 0.7.0 (Monad m constraint)</em></p><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:reverse-39-" class="def">reverse'</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#reverse%27" class="link">Source</a> <a href="#v:reverse-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:reverse" title="Streamly.Internal.Data.Stream.IsStream.Common">reverse</a></code> but several times faster, requires a <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a></code> instance.</p><p><em>Internal</em></p></div></div><a href="#g:4" id="g:4"><h1>Nesting</h1></a><div class="top"><p class="src"><a id="v:concatM" class="def">concatM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m (t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#concatM" class="link">Source</a> <a href="#v:concatM" class="selflink">#</a></p><div class="doc"><p>Given a stream value in the underlying monad, lift and join the underlying
 monad with the stream monad.</p><pre>concatM = concat . yieldM
concatM = concat . lift    -- requires <code>(MonadTrans t)</code>
concatM = join . lift      -- requires <code>(MonadTrans t</code>, <code>Monad (t m))</code>
</pre><p>See also: <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#v:concat" title="Data.Foldable">concat</a></code>, <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Traversable.html#v:sequence" title="Data.Traversable">sequence</a></code></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:concatMapM" class="def">concatMapM</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#concatMapM" class="link">Source</a> <a href="#v:concatMapM" class="selflink">#</a></p><div class="doc"><p>Map a stream producing monadic function on each element of the stream
 and then flatten the results into a single stream. Since the stream
 generation function is monadic, unlike <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#v:concatMap" title="Data.Foldable">concatMap</a></code>, it can produce an
 effect at the beginning of each iteration of the inner loop.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSeq" class="def">splitOnSeq</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#splitOnSeq" class="link">Source</a> <a href="#v:splitOnSeq" class="selflink">#</a></p><div class="doc"><p>Like <code>splitOn</code> but the separator is a sequence of elements instead of a
 single element.</p><p>For illustration, let's define a function that operates on pure lists:</p><pre>splitOnSeq' pat xs = S.toList $ S.splitOnSeq (A.fromList pat) (FL.toList) (S.fromList xs)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;&quot;
</code></strong>&gt; [&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;x&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;h&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;ello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;o&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hell&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;e&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;llo&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;l&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;ll&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;o&quot;]
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:splitOnSeq" title="Streamly.Internal.Data.Stream.IsStream.Common">splitOnSeq</a></code> is an inverse of <code>intercalate</code>. The following law always holds:</p><pre>intercalate . splitOn == id</pre><p>The following law holds when the separator is non-empty and contains none of
 the elements present in the input lists:</p><pre>splitOn . intercalate == id</pre><p><em>Internal</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>