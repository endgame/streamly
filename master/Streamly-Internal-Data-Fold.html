<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Fold</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Fold.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2019 Composewell Technologies<br />(c) 2013 Gabriel Gonzalez</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Fold</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Fold Type</a></li><li><a href="#g:2">Creating</a></li><li><a href="#g:3">Generators</a></li><li><a href="#g:4">Accumulators</a><ul><li><a href="#g:5">Semigroups and Monoids</a></li><li><a href="#g:6">Reducers</a></li><li><a href="#g:7">Saturating Reducers</a></li><li><a href="#g:8">Collectors</a></li></ul></li><li><a href="#g:9">Terminating Folds</a></li><li><a href="#g:10">Adapting</a></li><li><a href="#g:11">Running Incrementally</a></li><li><a href="#g:12">Output Transformations</a></li><li><a href="#g:13">Input Transformations</a><ul><li><a href="#g:14">Mapping</a></li><li><a href="#g:15">Filtering</a></li><li><a href="#g:16">Trimming</a></li></ul></li><li><a href="#g:17">Splitting</a></li><li><a href="#g:18">Distributing</a></li><li><a href="#g:19">Partitioning</a></li><li><a href="#g:20">Demultiplexing</a></li><li><a href="#g:21">Classifying</a></li><li><a href="#g:22">Unzipping</a></li><li><a href="#g:23">Nesting</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>See <a href="Streamly-Data-Fold.html">Streamly.Data.Fold</a> for an overview.</p><p>IMPORTANT: keep the signatures consistent with the folds in Streamly.Prelude</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Step">Step</a> s b<ul class="subs"><li>= <a href="#v:Partial">Partial</a> !s</li><li>| <a href="#v:Done">Done</a> !b</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Fold">Fold</a> m a b = <span class="keyword">forall</span> s. <a href="#v:Fold">Fold</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b)) (m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b)) (s -&gt; m b)</li><li class="src short"><a href="#v:mkAccum">mkAccum</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (s -&gt; a -&gt; s) -&gt; s -&gt; (s -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:mkAccum_">mkAccum_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:mkAccumM">mkAccumM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; (s -&gt; a -&gt; m s) -&gt; m s -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:mkAccumM_">mkAccumM_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:mkFold">mkFold</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (s -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b -&gt; (s -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:mkFold_">mkFold_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> b b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:mkFoldM">mkFoldM</a> :: (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b)) -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b) -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:mkFoldM_">mkFoldM_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> b b)) -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:yield">yield</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:yieldM">yieldM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:sconcat">sconcat</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a</li><li class="src short"><a href="#v:mconcat">mconcat</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a</li><li class="src short"><a href="#v:foldMap">foldMap</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> b) =&gt; (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:foldMapM">foldMapM</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> b) =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:drain">drain</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a ()</li><li class="src short"><a href="#v:drainBy">drainBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a ()</li><li class="src short"><a href="#v:drainBy2">drainBy2</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m c a ()</li><li class="src short"><a href="#v:last">last</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:length">length</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:mean">mean</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a</li><li class="src short"><a href="#v:variance">variance</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a</li><li class="src short"><a href="#v:stdDev">stdDev</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Numeric.html#t:Floating" title="Numeric">Floating</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a</li><li class="src short"><a href="#v:rollingHash">rollingHash</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a></li><li class="src short"><a href="#v:rollingHashWithSalt">rollingHashWithSalt</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a></li><li class="src short"><a href="#v:rollingHashFirstN">rollingHashFirstN</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a></li><li class="src short"><a href="#v:sum">sum</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a</li><li class="src short"><a href="#v:product">product</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a</li><li class="src short"><a href="#v:maximumBy">maximumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:maximum">maximum</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:minimumBy">minimumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:minimum">minimum</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:toList">toList</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a [a]</li><li class="src short"><a href="#v:toListRevF">toListRevF</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a [a]</li><li class="src short"><a href="#v:drainN">drainN</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a ()</li><li class="src short"><a href="#v:index">index</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:head">head</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:find">find</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:lookup">lookup</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (a, b) (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)</li><li class="src short"><a href="#v:findIndex">findIndex</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)</li><li class="src short"><a href="#v:elemIndex">elemIndex</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)</li><li class="src short"><a href="#v:null">null</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:elem">elem</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:notElem">notElem</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:all">all</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:any">any</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:and">and</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:or">or</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:hoist">hoist</a> :: (<span class="keyword">forall</span> x. m x -&gt; n x) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> n a b</li><li class="src short"><a href="#v:generally">generally</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:initialize">initialize</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b)</li><li class="src short"><a href="#v:runStep">runStep</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b)</li><li class="src short"><a href="#v:rsequence">rsequence</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:sequence">sequence</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:rmapM">rmapM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c</li><li class="src short"><a href="#v:mapM">mapM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c</li><li class="src short"><a href="#v:transform">transform</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Pipe-Types.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Types">Pipe</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c</li><li class="src short"><a href="#v:map">map</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r</li><li class="src short"><a href="#v:lmapM">lmapM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r</li><li class="src short"><a href="#v:filter">filter</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r</li><li class="src short"><a href="#v:filterM">filterM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r</li><li class="src short"><a href="#v:lcatMaybes">lcatMaybes</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) b</li><li class="src short"><a href="#v:mapMaybe">mapMaybe</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r</li><li class="src short"><a href="#v:takeLE">takeLE</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:takeByTime">takeByTime</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:sliceSepBy">sliceSepBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:sliceSepByMax">sliceSepByMax</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:sliceEndWith">sliceEndWith</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b</li><li class="src short"><a href="#v:splitAt">splitAt</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c)</li><li class="src short"><a href="#v:span">span</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c)</li><li class="src short"><a href="#v:break">break</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c)</li><li class="src short"><a href="#v:spanBy">spanBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c)</li><li class="src short"><a href="#v:spanByRolling">spanByRolling</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c)</li><li class="src short"><a href="#v:tee">tee</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c)</li><li class="src short"><a href="#v:teeWith">teeWith</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m x c</li><li class="src short"><a href="#v:teeWithFst">teeWithFst</a> :: (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a d</li><li class="src short"><a href="#v:teeWithMin">teeWithMin</a> :: (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a d</li><li class="src short"><a href="#v:distribute">distribute</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; [<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b] -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a [b]</li><li class="src short"><a href="#v:partitionByM">partitionByM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y)</li><li class="src short"><a href="#v:partitionByFstM">partitionByFstM</a> :: (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y)</li><li class="src short"><a href="#v:partitionByMinM">partitionByMinM</a> :: (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y)</li><li class="src short"><a href="#v:partitionBy">partitionBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y)</li><li class="src short"><a href="#v:partition">partition</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b c) (x, y)</li><li class="src short"><a href="#v:demux">demux</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (k, a) (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b)</li><li class="src short"><a href="#v:demuxWith">demuxWith</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; (a -&gt; (k, a')) -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a' b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b)</li><li class="src short"><a href="#v:demuxDefault">demuxDefault</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (k, a) b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (k, a) (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b, b)</li><li class="src short"><a href="#v:demuxDefaultWith">demuxDefaultWith</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; (a -&gt; (k, a')) -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a' b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (k, a') c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b, c)</li><li class="src short"><a href="#v:classify">classify</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (k, a) (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b)</li><li class="src short"><a href="#v:classifyWith">classifyWith</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; (a -&gt; k) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b)</li><li class="src short"><a href="#v:unzip">unzip</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (a, b) (x, y)</li><li class="src short"><a href="#v:unzipWith">unzipWith</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; (b, c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y)</li><li class="src short"><a href="#v:unzipWithM">unzipWithM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (b, c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y)</li><li class="src short"><a href="#v:unzipWithFstM">unzipWithFstM</a> :: (a -&gt; m (b, c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y)</li><li class="src short"><a href="#v:unzipWithMinM">unzipWithMinM</a> :: (a -&gt; m (b, c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y)</li><li class="src short"><a href="#v:many">many</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c</li><li class="src short"><a href="#v:intervalsOf">intervalsOf</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c</li><li class="src short"><a href="#v:chunksOf">chunksOf</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c</li><li class="src short"><a href="#v:chunksBetween">chunksBetween</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c</li><li class="src short"><a href="#v:concatSequence">concatSequence</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; t (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c</li><li class="src short"><a href="#v:concatMap">concatMap</a> :: (b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c</li><li class="src short"><a href="#v:duplicate">duplicate</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Fold Type</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Step" class="def">Step</a> s b <a href="src/Streamly.Internal.Data.Fold.Types.html#Step" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></p><div class="doc"><p>Represents the result of the <code>step</code> of a <code><a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a></code>.  <code><a href="Streamly-Internal-Data-Fold.html#v:Partial" title="Streamly.Internal.Data.Fold">Partial</a></code> returns an
 intermediate state of the fold, the fold step can be called again with the
 state or the driver can use <code>extract</code> on the state to get the result out.
 <code><a href="Streamly-Internal-Data-Fold.html#v:Done" title="Streamly.Internal.Data.Fold">Done</a></code> returns the final result and the fold cannot be driven further.</p><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Partial" class="def">Partial</a> !s</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Done" class="def">Done</a> !b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Step">Instances</h4><details id="i:Step" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Step:Bifunctor:1"></span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bifunctor.html#t:Bifunctor" title="Data.Bifunctor">Bifunctor</a> <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a></span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-270" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></td><td class="doc"><p>A bifunctor instance on <code><a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a></code>. <code>first</code> maps on the value held by <code><a href="Streamly-Internal-Data-Fold.html#v:Partial" title="Streamly.Internal.Data.Fold">Partial</a></code>
 and <code>second</code> maps on the result held by <code><a href="Streamly-Internal-Data-Fold.html#v:Done" title="Streamly.Internal.Data.Fold">Done</a></code>.</p><p><em>Internal</em></p></td></tr><tr><td colspan="2"><details id="i:id:Step:Bifunctor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:bimap">bimap</a> :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> b d <a href="#v:bimap" class="selflink">#</a></p><p class="src"><a href="#v:first">first</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> b c <a href="#v:first" class="selflink">#</a></p><p class="src"><a href="#v:second">second</a> :: (b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> a c <a href="#v:second" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Step:Functor:2"></span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-290" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></td><td class="doc"><p>Maps the function over the result held by <code><a href="Streamly-Internal-Data-Fold.html#v:Done" title="Streamly.Internal.Data.Fold">Done</a></code>.
 <code>
 fmap = <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bifunctor.html#v:second" title="Data.Bifunctor">second</a></code>
 </code></p><p><em>Internal</em></p></td></tr><tr><td colspan="2"><details id="i:id:Step:Functor:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Fold" class="def">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#Fold" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></p><div class="doc"><p>The type <code>Fold m a b</code> having constructor <code>Fold step initial extract</code>
 represents a left fold over an input stream of values of type <code>a</code> to a
 single value of type <code>b</code> in <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> <code>m</code>. The constructor is not exposed via
 exposed modules, smart constructors are provided to create folds.</p><p>The fold uses an intermediate state <code>s</code> as accumulator, the type <code>s</code> is
 specific to the fold. The initial value of the fold state <code>s</code> is returned by
 <code>initial</code>. The <code>step</code> function consumes an input and either returns the
 final result <code>b</code> if the fold is done or the next intermediate state (see
 <code><a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a></code>). At any point the fold driver can extract the result from the
 intermediate state using the <code>extract</code> function.</p><p><em>Since: 0.7.0</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><span class="keyword">forall</span> s. <a id="v:Fold" class="def">Fold</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b)) (m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b)) (s -&gt; m b)</td><td class="doc"><p><code>Fold </code> <code> step </code> <code> initial </code> <code> extract</code></p></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Fold">Instances</h4><details id="i:Fold" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Functor:1"></span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-438" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Maps a function on the output of the fold (the type <code>b</code>).</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Functor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a0 <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Applicative:2"></span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-544" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>The fold resulting from <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#v:-60--42--62-" title="Control.Applicative">&lt;*&gt;</a></code> distributes its input to both the argument
 folds and combines their output using the supplied function.</p><p><strong>Note:</strong> The Applicative behaviour will change in the next major release.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a0 <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a0 -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a0 <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Floating:3"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Numeric.html#t:Floating" title="Numeric">Floating</a> b) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Numeric.html#t:Floating" title="Numeric">Floating</a> (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-719" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Combines the fold outputs using their <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Numeric.html#t:Floating" title="Numeric">Floating</a></code> instances.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Floating:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pi">pi</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:pi" class="selflink">#</a></p><p class="src"><a href="#v:exp">exp</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:exp" class="selflink">#</a></p><p class="src"><a href="#v:log">log</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:log" class="selflink">#</a></p><p class="src"><a href="#v:sqrt">sqrt</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:sqrt" class="selflink">#</a></p><p class="src"><a href="#v:-42--42-">(**)</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:-42--42-" class="selflink">#</a></p><p class="src"><a href="#v:logBase">logBase</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:logBase" class="selflink">#</a></p><p class="src"><a href="#v:sin">sin</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:sin" class="selflink">#</a></p><p class="src"><a href="#v:cos">cos</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:cos" class="selflink">#</a></p><p class="src"><a href="#v:tan">tan</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:tan" class="selflink">#</a></p><p class="src"><a href="#v:asin">asin</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:asin" class="selflink">#</a></p><p class="src"><a href="#v:acos">acos</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:acos" class="selflink">#</a></p><p class="src"><a href="#v:atan">atan</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:atan" class="selflink">#</a></p><p class="src"><a href="#v:sinh">sinh</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:sinh" class="selflink">#</a></p><p class="src"><a href="#v:cosh">cosh</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:cosh" class="selflink">#</a></p><p class="src"><a href="#v:tanh">tanh</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:tanh" class="selflink">#</a></p><p class="src"><a href="#v:asinh">asinh</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:asinh" class="selflink">#</a></p><p class="src"><a href="#v:acosh">acosh</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:acosh" class="selflink">#</a></p><p class="src"><a href="#v:atanh">atanh</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:atanh" class="selflink">#</a></p><p class="src"><a href="#v:log1p">log1p</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:log1p" class="selflink">#</a></p><p class="src"><a href="#v:expm1">expm1</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:expm1" class="selflink">#</a></p><p class="src"><a href="#v:log1pexp">log1pexp</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:log1pexp" class="selflink">#</a></p><p class="src"><a href="#v:log1mexp">log1mexp</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:log1mexp" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Fractional:4"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> b) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-708" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Combines the fold outputs (type <code>b</code>) using their <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a></code> instances.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Fractional:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-47-">(/)</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:-47-" class="selflink">#</a></p><p class="src"><a href="#v:recip">recip</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:recip" class="selflink">#</a></p><p class="src"><a href="#v:fromRational">fromRational</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Rational" title="Prelude">Rational</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:fromRational" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Num:5"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> b) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-685" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Combines the fold outputs (type <code>b</code>) using their <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a></code> instances.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Num:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-43-">(+)</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:-43-" class="selflink">#</a></p><p class="src"><a href="#v:-45-">(-)</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:-45-" class="selflink">#</a></p><p class="src"><a href="#v:-42-">(*)</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:-42-" class="selflink">#</a></p><p class="src"><a href="#v:negate">negate</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:negate" class="selflink">#</a></p><p class="src"><a href="#v:abs">abs</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:abs" class="selflink">#</a></p><p class="src"><a href="#v:signum">signum</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:signum" class="selflink">#</a></p><p class="src"><a href="#v:fromInteger">fromInteger</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:fromInteger" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Semigroup:6"></span> (<a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> b, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-671" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Combines the outputs of the folds (the type <code>b</code>) using their <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code>
 instances.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Semigroup:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b0 =&gt; b0 -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Monoid:7"></span> (<a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> b, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> b, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-677" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Combines the outputs of the folds (the type <code>b</code>) using their <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a></code>
 instances.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Monoid:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b] -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:2" id="g:2"><h1>Creating</h1></a><div class="top"><p class="src"><a id="v:mkAccum" class="def">mkAccum</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (s -&gt; a -&gt; s) -&gt; s -&gt; (s -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkAccum" class="link">Source</a> <a href="#v:mkAccum" class="selflink">#</a></p><div class="doc"><p>Make an accumulating (non-terminating) fold using a pure step function, a
 pure initial state and a pure state extraction function.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkAccum_" class="def">mkAccum_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkAccum_" class="link">Source</a> <a href="#v:mkAccum_" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold.html#v:mkAccum" title="Streamly.Internal.Data.Fold">mkAccum</a></code> but the final state extracted is identical to the
 intermediate state.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkAccumM" class="def">mkAccumM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; (s -&gt; a -&gt; m s) -&gt; m s -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkAccumM" class="link">Source</a> <a href="#v:mkAccumM" class="selflink">#</a></p><div class="doc"><p>Make an accumulating (non-terminating) fold with an effectful step
 function, an initial state, and a state extraction function.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkAccumM_" class="def">mkAccumM_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkAccumM_" class="link">Source</a> <a href="#v:mkAccumM_" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold.html#v:mkAccumM" title="Streamly.Internal.Data.Fold">mkAccumM</a></code> but the final state extracted is identical to the
 intermediate state.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkFold" class="def">mkFold</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (s -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b -&gt; (s -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkFold" class="link">Source</a> <a href="#v:mkFold" class="selflink">#</a></p><div class="doc"><p>Make a terminating fold using a pure step function, a pure initial state
 and a pure state extraction function.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkFold_" class="def">mkFold_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> b b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkFold_" class="link">Source</a> <a href="#v:mkFold_" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold.html#v:mkFold" title="Streamly.Internal.Data.Fold">mkFold</a></code> but the final state extracted is identical to the
 intermediate state.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkFoldM" class="def">mkFoldM</a> :: (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b)) -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> s b) -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkFoldM" class="link">Source</a> <a href="#v:mkFoldM" class="selflink">#</a></p><div class="doc"><p>Make a terminating fold with an effectful step function and initial state,
 and a state extraction function.</p><pre>mkFoldM = Fold</pre><p>We can just use <code><a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a></code> but it is provided for completeness.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkFoldM_" class="def">mkFoldM_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> b b)) -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Step" title="Streamly.Internal.Data.Fold">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkFoldM_" class="link">Source</a> <a href="#v:mkFoldM_" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold.html#v:mkFoldM" title="Streamly.Internal.Data.Fold">mkFoldM</a></code> but the final state extracted is identical to the
 intermediate state.</p><p><em>Internal</em></p></div></div><a href="#g:3" id="g:3"><h1>Generators</h1></a><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><p>A fold that always yields a pure value without consuming any input.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:yieldM" class="def">yieldM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#yieldM" class="link">Source</a> <a href="#v:yieldM" class="selflink">#</a></p><div class="doc"><p>A fold that always yields the result of an effectful action without
 consuming any input.</p><p><em>Unimplemented</em></p></div></div><a href="#g:4" id="g:4"><h1>Accumulators</h1></a><a href="#g:5" id="g:5"><h2>Semigroups and Monoids</h2></a><div class="top"><p class="src"><a id="v:sconcat" class="def">sconcat</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a <a href="src/Streamly.Internal.Data.Fold.html#sconcat" class="link">Source</a> <a href="#v:sconcat" class="selflink">#</a></p><div class="doc"><p>Append the elements of an input stream to a provided starting value.</p><pre>S.fold (FL.sconcat 10) (S.map Sum $ S.enumerateFromTo 1 10)</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mconcat" class="def">mconcat</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a <a href="src/Streamly.Internal.Data.Fold.html#mconcat" class="link">Source</a> <a href="#v:mconcat" class="selflink">#</a></p><div class="doc"><p>Fold an input stream consisting of monoidal elements using <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#v:mappend" title="Data.Monoid">mappend</a></code>
 and <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#v:mempty" title="Data.Monoid">mempty</a></code>.</p><pre>S.fold FL.mconcat (S.map Sum $ S.enumerateFromTo 1 10)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldMap" class="def">foldMap</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> b) =&gt; (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.html#foldMap" class="link">Source</a> <a href="#v:foldMap" class="selflink">#</a></p><div class="doc"><pre>foldMap f = map f mconcat</pre><p>Make a fold from a pure function that folds the output of the function
 using <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#v:mappend" title="Data.Monoid">mappend</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#v:mempty" title="Data.Monoid">mempty</a></code>.</p><pre>S.fold (FL.foldMap Sum) $ S.enumerateFromTo 1 10</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldMapM" class="def">foldMapM</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> b) =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.html#foldMapM" class="link">Source</a> <a href="#v:foldMapM" class="selflink">#</a></p><div class="doc"><pre>foldMapM f = lmapM f mconcat</pre><p>Make a fold from a monadic function that folds the output of the function
 using <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#v:mappend" title="Data.Monoid">mappend</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#v:mempty" title="Data.Monoid">mempty</a></code>.</p><pre>S.fold (FL.foldMapM (return . Sum)) $ S.enumerateFromTo 1 10</pre><p><em>Since: 0.7.0</em></p></div></div><a href="#g:6" id="g:6"><h2>Reducers</h2></a><div class="top"><p class="src"><a id="v:drain" class="def">drain</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a () <a href="src/Streamly.Internal.Data.Fold.html#drain" class="link">Source</a> <a href="#v:drain" class="selflink">#</a></p><div class="doc"><p>A fold that drains all its input, running the effects and discarding the
 results.</p><pre>drain = drainBy (const (return ()))</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:drainBy" class="def">drainBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a () <a href="src/Streamly.Internal.Data.Fold.html#drainBy" class="link">Source</a> <a href="#v:drainBy" class="selflink">#</a></p><div class="doc"><pre>drainBy f = lmapM f drain
drainBy = FL.foldMapM (void . f)</pre><p>Drain all input after passing it through a monadic function. This is the
 dual of mapM_ on stream producers.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:drainBy2" class="def">drainBy2</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m c a () <a href="src/Streamly.Internal.Data.Fold.html#drainBy2" class="link">Source</a> <a href="#v:drainBy2" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:last" class="def">last</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Fold.html#last" class="link">Source</a> <a href="#v:last" class="selflink">#</a></p><div class="doc"><p>Extract the last element of the input stream, if any.</p><pre>last = fmap getLast $ FL.foldMap (Last . Just)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:length" class="def">length</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Fold.html#length" class="link">Source</a> <a href="#v:length" class="selflink">#</a></p><div class="doc"><p>Determine the length of the input stream.</p><pre>length = fmap getSum $ foldMap (Sum . const  1)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:mean" class="def">mean</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a <a href="src/Streamly.Internal.Data.Fold.html#mean" class="link">Source</a> <a href="#v:mean" class="selflink">#</a></p><div class="doc"><p>Compute a numerically stable arithmetic mean of all elements in the input
 stream.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:variance" class="def">variance</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a <a href="src/Streamly.Internal.Data.Fold.html#variance" class="link">Source</a> <a href="#v:variance" class="selflink">#</a></p><div class="doc"><p>Compute a numerically stable (population) variance over all elements in
 the input stream.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:stdDev" class="def">stdDev</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Numeric.html#t:Floating" title="Numeric">Floating</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a <a href="src/Streamly.Internal.Data.Fold.html#stdDev" class="link">Source</a> <a href="#v:stdDev" class="selflink">#</a></p><div class="doc"><p>Compute a numerically stable (population) standard deviation over all
 elements in the input stream.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:rollingHash" class="def">rollingHash</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> <a href="src/Streamly.Internal.Data.Fold.html#rollingHash" class="link">Source</a> <a href="#v:rollingHash" class="selflink">#</a></p><div class="doc"><p>Compute an <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code> sized polynomial rolling hash of a stream.</p><pre>rollingHash = rollingHashWithSalt defaultSalt</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:rollingHashWithSalt" class="def">rollingHashWithSalt</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> <a href="src/Streamly.Internal.Data.Fold.html#rollingHashWithSalt" class="link">Source</a> <a href="#v:rollingHashWithSalt" class="selflink">#</a></p><div class="doc"><p>Compute an <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code> sized polynomial rolling hash</p><pre>H = salt * k ^ n + c1 * k ^ (n - 1) + c2 * k ^ (n - 2) + ... + cn * k ^ 0</pre><p>Where <code>c1</code>, <code>c2</code>, <code>cn</code> are the elements in the input stream and <code>k</code> is a
 constant.</p><p>This hash is often used in Rabin-Karp string search algorithm.</p><p>See <a href="https://en.wikipedia.org/wiki/Rolling_hash">https://en.wikipedia.org/wiki/Rolling_hash</a></p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:rollingHashFirstN" class="def">rollingHashFirstN</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> <a href="src/Streamly.Internal.Data.Fold.html#rollingHashFirstN" class="link">Source</a> <a href="#v:rollingHashFirstN" class="selflink">#</a></p><div class="doc"><p>Compute an <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></code> sized polynomial rolling hash of the first n elements of
 a stream.</p><pre>rollingHashFirstN = takeLE n rollingHash</pre></div></div><a href="#g:7" id="g:7"><h2>Saturating Reducers</h2></a><div class="doc"><p><code><a href="Streamly-Internal-Data-Fold.html#v:product" title="Streamly.Internal.Data.Fold">product</a></code> terminates if it becomes 0. Other folds can theoretically
 saturate on bounded types, and therefore terminate, however, they will
 run forever on unbounded types like Integer/Double.</p></div><div class="top"><p class="src"><a id="v:sum" class="def">sum</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a <a href="src/Streamly.Internal.Data.Fold.html#sum" class="link">Source</a> <a href="#v:sum" class="selflink">#</a></p><div class="doc"><p>Determine the sum of all elements of a stream of numbers. Returns additive
 identity (<code>0</code>) when the stream is empty. Note that this is not numerically
 stable for floating point numbers.</p><pre>sum = fmap getSum $ FL.foldMap Sum</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:product" class="def">product</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a a <a href="src/Streamly.Internal.Data.Fold.html#product" class="link">Source</a> <a href="#v:product" class="selflink">#</a></p><div class="doc"><p>Determine the product of all elements of a stream of numbers. Returns
 multiplicative identity (<code>1</code>) when the stream is empty. The fold terminates
 when it encounters (<code>0</code>) in its input.</p><pre>product = fmap getProduct $ FL.foldMap Product</pre><p><em>Since 0.8.0 (Added <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a></code> constraint)</em></p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:maximumBy" class="def">maximumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Fold.html#maximumBy" class="link">Source</a> <a href="#v:maximumBy" class="selflink">#</a></p><div class="doc"><p>Determine the maximum element in a stream using the supplied comparison
 function.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:maximum" class="def">maximum</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Fold.html#maximum" class="link">Source</a> <a href="#v:maximum" class="selflink">#</a></p><div class="doc"><pre>maximum = <code><a href="Streamly-Internal-Data-Fold.html#v:maximumBy" title="Streamly.Internal.Data.Fold">maximumBy</a></code> compare
</pre><p>Determine the maximum element in a stream.</p><p>Compare with <code>FL.foldMap Max</code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:minimumBy" class="def">minimumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Fold.html#minimumBy" class="link">Source</a> <a href="#v:minimumBy" class="selflink">#</a></p><div class="doc"><p>Computes the minimum element with respect to the given comparison function</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:minimum" class="def">minimum</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Fold.html#minimum" class="link">Source</a> <a href="#v:minimum" class="selflink">#</a></p><div class="doc"><p>Determine the minimum element in a stream using the supplied comparison
 function.</p><pre>minimum = <code><a href="Streamly-Internal-Data-Fold.html#v:minimumBy" title="Streamly.Internal.Data.Fold">minimumBy</a></code> compare
</pre><p>Compare with <code>FL.foldMap Min</code>.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:8" id="g:8"><h2>Collectors</h2></a><div class="top"><p class="src"><a id="v:toList" class="def">toList</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a [a] <a href="src/Streamly.Internal.Data.Fold.Types.html#toList" class="link">Source</a> <a href="#v:toList" class="selflink">#</a></p><div class="doc"><p>Folds the input stream to a list.</p><p><em>Warning!</em> working on large lists accumulated as buffers in memory could be
 very inefficient, consider using <a href="Streamly-Data-Array-Foreign.html">Streamly.Data.Array.Foreign</a>
 instead.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:toListRevF" class="def">toListRevF</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a [a] <a href="src/Streamly.Internal.Data.Fold.html#toListRevF" class="link">Source</a> <a href="#v:toListRevF" class="selflink">#</a></p><div class="doc"><p>Buffers the input stream to a list in the reverse order of the input.</p><p><em>Warning!</em> working on large lists accumulated as buffers in memory could be
 very inefficient, consider using <a href="Streamly-Array.html">Streamly.Array</a> instead.</p><p><em>Since: 0.7.0</em></p></div></div><div class="doc"><p>This is more efficient than <code><a href="Streamly-Internal-Data-Fold.html#v:toList" title="Streamly.Internal.Data.Fold">toList</a></code>. toList is
 exactly the same as reversing the list after <code><a href="Streamly-Internal-Data-Fold.html#v:toListRevF" title="Streamly.Internal.Data.Fold">toListRevF</a></code>.</p></div><a href="#g:9" id="g:9"><h1>Terminating Folds</h1></a><div class="top"><p class="src"><a id="v:drainN" class="def">drainN</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a () <a href="src/Streamly.Internal.Data.Fold.html#drainN" class="link">Source</a> <a href="#v:drainN" class="selflink">#</a></p><div class="doc"><p>A fold that drains the first n elements of its input, running the effects
 and discarding the results.</p></div></div><div class="top"><p class="src"><a id="v:index" class="def">index</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Fold.html#index" class="link">Source</a> <a href="#v:index" class="selflink">#</a></p><div class="doc"><p>Lookup the element at the given index.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:head" class="def">head</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Fold.html#head" class="link">Source</a> <a href="#v:head" class="selflink">#</a></p><div class="doc"><p>Extract the first element of the stream, if any.</p><pre>head = fmap getFirst $ FL.foldMap (First . Just)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:find" class="def">find</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Fold.html#find" class="link">Source</a> <a href="#v:find" class="selflink">#</a></p><div class="doc"><p>Returns the first element that satisfies the given predicate.</p><pre>find p = fmap getFirst $
    FL.foldMap (x -&gt; First (if p x then Just x else Nothing))
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:lookup" class="def">lookup</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (a, b) (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) <a href="src/Streamly.Internal.Data.Fold.html#lookup" class="link">Source</a> <a href="#v:lookup" class="selflink">#</a></p><div class="doc"><p>In a stream of (key-value) pairs <code>(a, b)</code>, return the value <code>b</code> of the
 first pair where the key equals the given value <code>a</code>.</p><pre>lookup = snd &lt;$&gt; find ((==) . fst)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:findIndex" class="def">findIndex</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) <a href="src/Streamly.Internal.Data.Fold.html#findIndex" class="link">Source</a> <a href="#v:findIndex" class="selflink">#</a></p><div class="doc"><p>Returns the first index that satisfies the given predicate.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:elemIndex" class="def">elemIndex</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) <a href="src/Streamly.Internal.Data.Fold.html#elemIndex" class="link">Source</a> <a href="#v:elemIndex" class="selflink">#</a></p><div class="doc"><p>Returns the first index where a given value is found in the stream.</p><pre>elemIndex a = findIndex (== a)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:null" class="def">null</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Fold.html#null" class="link">Source</a> <a href="#v:null" class="selflink">#</a></p><div class="doc"><p>Return <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if the input stream is empty.</p><pre>null = fmap isJust head</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:elem" class="def">elem</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Fold.html#elem" class="link">Source</a> <a href="#v:elem" class="selflink">#</a></p><div class="doc"><p>Return <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if the given element is present in the stream.</p><pre>elem a = any (== a)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:notElem" class="def">notElem</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Fold.html#notElem" class="link">Source</a> <a href="#v:notElem" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if the given element is not present in the stream.</p><pre>notElem a = all (/= a)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:all" class="def">all</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Fold.html#all" class="link">Source</a> <a href="#v:all" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if all elements of a stream satisfy a predicate.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold (Fold.all (== 0)) $ Stream.fromList [1,0,1]
</code></strong>&gt; False
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:any" class="def">any</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Fold.html#any" class="link">Source</a> <a href="#v:any" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if any of the elements of a stream satisfies a predicate.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold (Fold.any (== 0)) $ Stream.fromList [1,0,1]
</code></strong>&gt; True
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:and" class="def">and</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Fold.html#and" class="link">Source</a> <a href="#v:and" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if all elements are <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>, <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a></code> otherwise</p><pre>and = all (== True)
and = fmap getAll . FL.foldMap All</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:or" class="def">or</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Fold.html#or" class="link">Source</a> <a href="#v:or" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if any element is <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>, <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a></code> otherwise</p><pre>or = any (== True)
or = fmap getAny . FL.foldMap Any</pre><p><em>Since: 0.7.0</em></p></div></div><a href="#g:10" id="g:10"><h1>Adapting</h1></a><div class="top"><p class="src"><a id="v:hoist" class="def">hoist</a> :: (<span class="keyword">forall</span> x. m x -&gt; n x) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> n a b <a href="src/Streamly.Internal.Data.Fold.html#hoist" class="link">Source</a> <a href="#v:hoist" class="selflink">#</a></p><div class="doc"><p>Change the underlying monad of a fold</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:generally" class="def">generally</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.html#generally" class="link">Source</a> <a href="#v:generally" class="selflink">#</a></p><div class="doc"><p>Adapt a pure fold to any monad</p><pre>generally = hoist (return . runIdentity)</pre><p><em>Internal</em></p></div></div><a href="#g:11" id="g:11"><h1>Running Incrementally</h1></a><div class="top"><p class="src"><a id="v:initialize" class="def">initialize</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b) <a href="src/Streamly.Internal.Data.Fold.Types.html#initialize" class="link">Source</a> <a href="#v:initialize" class="selflink">#</a></p><div class="doc"><p>Run the initialization effect of a fold. The returned fold would use the
 value returned by this effect as its initial value.</p></div></div><div class="top"><p class="src"><a id="v:runStep" class="def">runStep</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b) <a href="src/Streamly.Internal.Data.Fold.Types.html#runStep" class="link">Source</a> <a href="#v:runStep" class="selflink">#</a></p><div class="doc"><p>Run one step of a fold and store the accumulator as an initial value in
 the returned fold.</p></div></div><a href="#g:12" id="g:12"><h1>Output Transformations</h1></a><div class="top"><p class="src"><a id="v:rsequence" class="def">rsequence</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.html#rsequence" class="link">Source</a> <a href="#v:rsequence" class="selflink">#</a></p><div class="doc"><p>Flatten the monadic output of a fold to pure output.</p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:sequence" class="def">sequence</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.html#sequence" class="link">Source</a> <a href="#v:sequence" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Use rsequence instead</p></div><p>Flatten the monadic output of a fold to pure output.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:rmapM" class="def">rmapM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.html#rmapM" class="link">Source</a> <a href="#v:rmapM" class="selflink">#</a></p><div class="doc"><p>Map a monadic function on the output of a fold.</p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:mapM" class="def">mapM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.html#mapM" class="link">Source</a> <a href="#v:mapM" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Use rmapM instead</p></div><p>Map a monadic function on the output of a fold.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:13" id="g:13"><h1>Input Transformations</h1></a><a href="#g:14" id="g:14"><h2>Mapping</h2></a><div class="top"><p class="src"><a id="v:transform" class="def">transform</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Pipe-Types.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Types">Pipe</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.html#transform" class="link">Source</a> <a href="#v:transform" class="selflink">#</a></p><div class="doc"><p>Apply a transformation on a <code><a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a></code> using a <code><a href="Streamly-Internal-Data-Pipe-Types.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Types">Pipe</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:map" class="def">map</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Types.html#map" class="link">Source</a> <a href="#v:map" class="selflink">#</a></p><div class="doc"><p><code>(map f fold)</code> maps the function <code>f</code> on the input of the fold.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.fold (FL.map (\x -&gt; x * x) FL.sum) (S.enumerateFromTo 1 100)
</code></strong>338350
</pre><p><strong>Note</strong>: This is not the same as <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code>. <code>map</code> is contravariant where as
 <code>fmap</code> is covariant.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:lmapM" class="def">lmapM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Types.html#lmapM" class="link">Source</a> <a href="#v:lmapM" class="selflink">#</a></p><div class="doc"><p><code>(lmapM f fold)</code> maps the monadic function <code>f</code> on the input of the fold.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:15" id="g:15"><h2>Filtering</h2></a><div class="top"><p class="src"><a id="v:filter" class="def">filter</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Types.html#filter" class="link">Source</a> <a href="#v:filter" class="selflink">#</a></p><div class="doc"><p>Include only those elements that pass a predicate.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.fold (filter (&gt; 5) FL.sum) [1..10]
</code></strong>40
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:filterM" class="def">filterM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Types.html#filterM" class="link">Source</a> <a href="#v:filterM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold.html#v:filter" title="Streamly.Internal.Data.Fold">filter</a></code> but with a monadic predicate.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:lcatMaybes" class="def">lcatMaybes</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) b <a href="src/Streamly.Internal.Data.Fold.Types.html#lcatMaybes" class="link">Source</a> <a href="#v:lcatMaybes" class="selflink">#</a></p><div class="doc"><p>Transform a fold from a pure input to a <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> input, consuming only
 <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code> values.</p></div></div><div class="top"><p class="src"><a id="v:mapMaybe" class="def">mapMaybe</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.html#mapMaybe" class="link">Source</a> <a href="#v:mapMaybe" class="selflink">#</a></p><div class="doc"><p><code>mapMaybe f fold</code> maps a <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> returning function <code>f</code> on the input of
 the fold, filters out <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> elements, and return the values extracted
 from <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>f x = if even x then Just x else Nothing
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fld = Fold.mapMaybe f Fold.toList
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold fld (Stream.enumerateFromTo 1 10)
</code></strong>[2,4,6,8]
</pre><p><em>Internal</em></p></div></div><a href="#g:16" id="g:16"><h2>Trimming</h2></a><div class="top"><p class="src"><a id="v:takeLE" class="def">takeLE</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#takeLE" class="link">Source</a> <a href="#v:takeLE" class="selflink">#</a></p><div class="doc"><p>Take at most <code>n</code> input elements and fold them using the supplied fold.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold (Fold.takeLE 1 Fold.toList) $ Stream.fromList [1]
</code></strong>[1]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold (Fold.takeLE (-1) Fold.toList) $ Stream.fromList [1]
</code></strong>[]
</pre><p><em>Internal</em></p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:takeByTime" class="def">takeByTime</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#takeByTime" class="link">Source</a> <a href="#v:takeByTime" class="selflink">#</a></p><div class="doc"><p><code>takeByTime n fold</code> uses <code>fold</code> to fold the input items arriving within a
 window of first <code>n</code> seconds.</p><p>Stops when <code>fold</code> stops or when the timeout occurs.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:sliceSepBy" class="def">sliceSepBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.html#sliceSepBy" class="link">Source</a> <a href="#v:sliceSepBy" class="selflink">#</a></p><div class="doc"><p>Consume the input until it encounters an infixed separator element (i.e.
 when the supplied predicate succeeds), dropping the separator.</p><p>Repeated applications of <code><a href="Streamly-Internal-Data-Fold.html#v:sliceSepBy" title="Streamly.Internal.Data.Fold">sliceSepBy</a></code> splits the stream on separator
 elements determined by the supplied predicate, separator is considered as
 infixed between two segments, if one side of the separator is missing then
 it is parsed as an empty stream.  The supplied <code><a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a></code> is applied on the
 split segments. With <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#v:-45-" title="Prelude">-</a></code> representing non-separator elements and <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as
 separator, repeated <code><a href="Streamly-Internal-Data-Fold.html#v:sliceSepBy" title="Streamly.Internal.Data.Fold">sliceSepBy</a></code> splits the stream as follows:</p><pre>&quot;--.--&quot; =&gt; &quot;--&quot; &quot;--&quot;
&quot;--.&quot;   =&gt; &quot;--&quot; &quot;&quot;
&quot;.--&quot;   =&gt; &quot;&quot;   &quot;--&quot;
</pre><p>Repeated applications of <code>Fold.sliceSepBy (== x)</code> on the input stream gives us
 an inverse of <code>Stream.intercalate (Stream.yield x)</code></p><pre>Stream.splitOn pred f = Stream.foldMany (Fold.sliceSepBy pred f)</pre><p>Let's use the following definition for illustration:</p><pre>splitOn p = Stream.foldMany (Fold.sliceSepBy pred Fold.toList)
splitOn' p = Stream.toList . splitOn p . Stream.fromList</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.&quot;
</code></strong>[&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.a&quot;
</code></strong>&gt; [&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a..b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;,&quot;b&quot;]
</pre><p>Stops - when the predicate succeeds.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:sliceSepByMax" class="def">sliceSepByMax</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.html#sliceSepByMax" class="link">Source</a> <a href="#v:sliceSepByMax" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold.html#v:sliceSepBy" title="Streamly.Internal.Data.Fold">sliceSepBy</a></code> but terminates a parse even before the separator
 is encountered if its size exceeds the specified maximum limit.</p><pre>take n = PR.sliceSepByMax (const True) n
sliceSepBy p = PR.sliceSepByMax p maxBound</pre><p>Let's use the following definitions for illustration:</p><pre>splitOn p n = PR.many FL.toList $ PR.sliceSepByMax p n (FL.toList)
splitOn' p n = S.parse (splitOn p n) . S.fromList</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') 0 &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') 0 &quot;a&quot;
</code></strong>infinite list of empty strings
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') 3 &quot;hello.world&quot;
</code></strong>[&quot;hel&quot;,&quot;lo&quot;,&quot;wor&quot;,&quot;ld&quot;]
</pre><p>If the separator is found and the limit is reached at the same time then it
 behaves just like <code><a href="Streamly-Internal-Data-Fold.html#v:sliceSepBy" title="Streamly.Internal.Data.Fold">sliceSepBy</a></code> i.e. the separator is dropped.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') 0 &quot;.&quot;
</code></strong>[&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') 0 &quot;..&quot;
</code></strong>[&quot;&quot;,&quot;&quot;,&quot;&quot;]
</pre><p>Stops - when the predicate succeeds or the limit is reached.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:sliceEndWith" class="def">sliceEndWith</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.html#sliceEndWith" class="link">Source</a> <a href="#v:sliceEndWith" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an element succeeds the predicate. Also take
 the element on which the predicate succeeded. The succeeding element is
 treated as a suffix separator which is kept in the output segement.</p><ul><li>Stops - when the predicate succeeds.</li></ul><pre>Stream.splitWithSuffix pred f = Stream.foldMany (Fold.sliceEndWith pred f)</pre><p><em>Internal</em></p></div></div><a href="#g:17" id="g:17"><h1>Splitting</h1></a><div class="top"><p class="src"><a id="v:splitAt" class="def">splitAt</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c) <a href="src/Streamly.Internal.Data.Fold.html#splitAt" class="link">Source</a> <a href="#v:splitAt" class="selflink">#</a></p><div class="doc"><p><code>splitAt n f1 f2</code> composes folds <code>f1</code> and <code>f2</code> such that first <code>n</code>
 elements of its input are consumed by fold <code>f1</code> and the rest of the stream
 is consumed by fold <code>f2</code>.</p><pre>let splitAt_ n xs = S.fold (FL.splitAt n FL.toList FL.toList) $ S.fromList xs</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ 6 &quot;Hello World!&quot;
</code></strong>&gt; (&quot;Hello &quot;,&quot;World!&quot;)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ (-1) [1,2,3]
</code></strong>&gt; ([],[1,2,3])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ 0 [1,2,3]
</code></strong>&gt; ([],[1,2,3])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ 1 [1,2,3]
</code></strong>&gt; ([1],[2,3])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ 3 [1,2,3]
</code></strong>&gt; ([1,2,3],[])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ 4 [1,2,3]
</code></strong>&gt; ([1,2,3],[])
</pre><pre>splitAt n f1 f2 = splitWith (,) (takeLE n f1) f2</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:span" class="def">span</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c) <a href="src/Streamly.Internal.Data.Fold.html#span" class="link">Source</a> <a href="#v:span" class="selflink">#</a></p><div class="doc"><p><code>span p f1 f2</code> composes folds <code>f1</code> and <code>f2</code> such that <code>f1</code> consumes the
 input as long as the predicate <code>p</code> is <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>.  <code>f2</code> consumes the rest of the
 input.</p><pre>let span_ p xs = S.fold (FL.span p FL.toList FL.toList) $ S.fromList xs</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>span_ (&lt; 1) [1,2,3]
</code></strong>&gt; ([],[1,2,3])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>span_ (&lt; 2) [1,2,3]
</code></strong>&gt; ([1],[2,3])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>span_ (&lt; 4) [1,2,3]
</code></strong>&gt; ([1,2,3],[])
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:break" class="def">break</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c) <a href="src/Streamly.Internal.Data.Fold.html#break" class="link">Source</a> <a href="#v:break" class="selflink">#</a></p><div class="doc"><pre>break p = span (not . p)</pre><p>Break as soon as the predicate becomes <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>. <code>break p f1 f2</code> composes
 folds <code>f1</code> and <code>f2</code> such that <code>f1</code> stops consuming input as soon as the
 predicate <code>p</code> becomes <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>. The rest of the input is consumed <code>f2</code>.</p><p>This is the binary version of <code>splitBy</code>.</p><pre>let break_ p xs = S.fold (S.break p FL.toList FL.toList) $ S.fromList xs</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>break_ (&lt; 1) [3,2,1]
</code></strong>&gt; ([3,2,1],[])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>break_ (&lt; 2) [3,2,1]
</code></strong>&gt; ([3,2],[1])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>break_ (&lt; 4) [3,2,1]
</code></strong>&gt; ([],[3,2,1])
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:spanBy" class="def">spanBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c) <a href="src/Streamly.Internal.Data.Fold.html#spanBy" class="link">Source</a> <a href="#v:spanBy" class="selflink">#</a></p><div class="doc"><p>Break the input stream into two groups, the first group takes the input as
 long as the predicate applied to the first element of the stream and next
 input element holds <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>, the second group takes the rest of the input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:spanByRolling" class="def">spanByRolling</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c) <a href="src/Streamly.Internal.Data.Fold.html#spanByRolling" class="link">Source</a> <a href="#v:spanByRolling" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold.html#v:spanBy" title="Streamly.Internal.Data.Fold">spanBy</a></code> but applies the predicate in a rolling fashion i.e.
 predicate is applied to the previous and the next input elements.</p><p><em>Internal</em></p></div></div><a href="#g:18" id="g:18"><h1>Distributing</h1></a><div class="top"><p class="src"><a id="v:tee" class="def">tee</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (b, c) <a href="src/Streamly.Internal.Data.Fold.html#tee" class="link">Source</a> <a href="#v:tee" class="selflink">#</a></p><div class="doc"><p>Distribute one copy of the stream to each fold and zip the results.</p><pre>                |-------Fold m a b--------|
---stream m a---|                         |---m (b,c)
                |-------Fold m a c--------|
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.fold (FL.tee FL.sum FL.length) (S.enumerateFromTo 1.0 100.0)
</code></strong>(5050.0,100)
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:teeWith" class="def">teeWith</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m x c <a href="src/Streamly.Internal.Data.Fold.Types.html#teeWith" class="link">Source</a> <a href="#v:teeWith" class="selflink">#</a></p><div class="doc"><p><code>teeWith k f1 f2</code> distributes its input to both <code>f1</code> and <code>f2</code> until both
 of them terminate and combines their output using <code>k</code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithFst" class="def">teeWithFst</a> :: (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a d <a href="src/Streamly.Internal.Data.Fold.Types.html#teeWithFst" class="link">Source</a> <a href="#v:teeWithFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold.html#v:teeWith" title="Streamly.Internal.Data.Fold">teeWith</a></code> but terminates when the first fold terminates.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithMin" class="def">teeWithMin</a> :: (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a d <a href="src/Streamly.Internal.Data.Fold.Types.html#teeWithMin" class="link">Source</a> <a href="#v:teeWithMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold.html#v:teeWith" title="Streamly.Internal.Data.Fold">teeWith</a></code> but terminates when any fold terminates.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:distribute" class="def">distribute</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; [<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b] -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a [b] <a href="src/Streamly.Internal.Data.Fold.html#distribute" class="link">Source</a> <a href="#v:distribute" class="selflink">#</a></p><div class="doc"><p>Distribute one copy of the stream to each fold and collect the results in
 a container.</p><pre>
                |-------Fold m a b--------|
---stream m a---|                         |---m [b]
                |-------Fold m a b--------|
                |                         |
                           ...
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.fold (FL.distribute [FL.sum, FL.length]) (S.enumerateFromTo 1 5)
</code></strong>[15,5]
</pre><p>This is the consumer side dual of the producer side <code><a href="Streamly-Internal-Data-Fold.html#v:sequence" title="Streamly.Internal.Data.Fold">sequence</a></code> operation.</p><p>Stops when all the folds stop.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:19" id="g:19"><h1>Partitioning</h1></a><div class="top"><p class="src"><a id="v:partitionByM" class="def">partitionByM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y) <a href="src/Streamly.Internal.Data.Fold.html#partitionByM" class="link">Source</a> <a href="#v:partitionByM" class="selflink">#</a></p><div class="doc"><p>Partition the input over two folds using an <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> partitioning
 predicate.</p><pre>
                                    |-------Fold b x--------|
-----stream m a --&gt; (Either b c)----|                       |----(x,y)
                                    |-------Fold c y--------|
</pre><p>Send input to either fold randomly:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import System.Random (randomIO)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>randomly a = randomIO &gt;&gt;= \x -&gt; return $ if x then Left a else Right a
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.fold (FL.partitionByM randomly FL.length FL.length) (S.enumerateFromTo 1 100)
</code></strong>(59,41)
</pre><p>Send input to the two folds in a proportion of 2:1:</p><pre>import Data.IORef (newIORef, readIORef, writeIORef)
proportionately m n = do
 ref &lt;- newIORef $ cycle $ concat [replicate m Left, replicate n Right]
 return $ \a -&gt; do
     r &lt;- readIORef ref
     writeIORef ref $ tail r
     return $ head r a

main = do
 f &lt;- proportionately 2 1
 r &lt;- S.fold (FL.partitionByM f FL.length FL.length) (S.enumerateFromTo (1 :: Int) 100)
 print r
</pre><pre>(67,33)
</pre><p>This is the consumer side dual of the producer side <code>mergeBy</code> operation.</p><p>When one fold is done, any input meant for it is ignored until the other
 fold is also done.</p><p>Stops when both the folds stop.</p><p><em>See also: <code><a href="Streamly-Internal-Data-Fold.html#v:partitionByFstM" title="Streamly.Internal.Data.Fold">partitionByFstM</a></code> and <code><a href="Streamly-Internal-Data-Fold.html#v:partitionByMinM" title="Streamly.Internal.Data.Fold">partitionByMinM</a></code>.</em></p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:partitionByFstM" class="def">partitionByFstM</a> :: (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y) <a href="src/Streamly.Internal.Data.Fold.html#partitionByFstM" class="link">Source</a> <a href="#v:partitionByFstM" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold.html#v:partitionByM" title="Streamly.Internal.Data.Fold">partitionByM</a></code> but terminates when the first fold terminates.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:partitionByMinM" class="def">partitionByMinM</a> :: (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y) <a href="src/Streamly.Internal.Data.Fold.html#partitionByMinM" class="link">Source</a> <a href="#v:partitionByMinM" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold.html#v:partitionByM" title="Streamly.Internal.Data.Fold">partitionByM</a></code> but terminates when any fold terminates.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:partitionBy" class="def">partitionBy</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y) <a href="src/Streamly.Internal.Data.Fold.html#partitionBy" class="link">Source</a> <a href="#v:partitionBy" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Fold.html#v:partitionByM" title="Streamly.Internal.Data.Fold">partitionByM</a></code> but with a pure partition function.</p><p>Count even and odd numbers in a stream:</p><pre>&gt;&gt;&gt; let f = FL.partitionBy (\n -&gt; if even n then Left n else Right n)
                      (fmap ((&quot;Even &quot; ++) . show) FL.length)
                      (fmap ((&quot;Odd &quot;  ++) . show) FL.length)
  in S.fold f (S.enumerateFromTo 1 100)
(&quot;Even 50&quot;,&quot;Odd 50&quot;)
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:partition" class="def">partition</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b c) (x, y) <a href="src/Streamly.Internal.Data.Fold.html#partition" class="link">Source</a> <a href="#v:partition" class="selflink">#</a></p><div class="doc"><p>Compose two folds such that the combined fold accepts a stream of <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code>
 and routes the <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code> values to the first fold and <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Either.html#v:Right" title="Data.Either">Right</a></code> values to the
 second fold.</p><pre>partition = partitionBy id</pre><p><em>Since: 0.7.0</em></p></div></div><a href="#g:20" id="g:20"><h1>Demultiplexing</h1></a><div class="top"><p class="src"><a id="v:demux" class="def">demux</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (k, a) (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b) <a href="src/Streamly.Internal.Data.Fold.html#demux" class="link">Source</a> <a href="#v:demux" class="selflink">#</a></p><div class="doc"><p>Fold a stream of key value pairs using a map of specific folds for each
 key into a map from keys to the results of fold outputs of the corresponding
 values.</p><pre>&gt; let table = Data.Map.fromList [(&quot;SUM&quot;, FL.sum), (&quot;PRODUCT&quot;, FL.product)]
      input = S.fromList [(&quot;SUM&quot;,1),(&quot;PRODUCT&quot;,2),(&quot;SUM&quot;,3),(&quot;PRODUCT&quot;,4)]
  in S.fold (FL.demux table) input
fromList [(<a href="PRODUCT.html">PRODUCT</a>,8),(<a href="SUM.html">SUM</a>,4)]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:demuxWith" class="def">demuxWith</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; (a -&gt; (k, a')) -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a' b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b) <a href="src/Streamly.Internal.Data.Fold.html#demuxWith" class="link">Source</a> <a href="#v:demuxWith" class="selflink">#</a></p><div class="doc"><p>Split the input stream based on a key field and fold each split using a
 specific fold collecting the results in a map from the keys to the results.
 Useful for cases like protocol handlers to handle different type of packets
 using different handlers.</p><pre>
                            |-------Fold m a b
-----stream m a-----Map-----|
                            |-------Fold m a b
                            |
                                      ...
</pre><p>Any input that does not map to a fold in the input Map is silently ignored.</p><pre>demuxWith f kv = fmap fst $ demuxDefaultWith f kv drain</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:demuxDefault" class="def">demuxDefault</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (k, a) b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (k, a) (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b, b) <a href="src/Streamly.Internal.Data.Fold.html#demuxDefault" class="link">Source</a> <a href="#v:demuxDefault" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:demuxDefaultWith" class="def">demuxDefaultWith</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; (a -&gt; (k, a')) -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a' b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (k, a') c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b, c) <a href="src/Streamly.Internal.Data.Fold.html#demuxDefaultWith" class="link">Source</a> <a href="#v:demuxDefaultWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold.html#v:demuxWith" title="Streamly.Internal.Data.Fold">demuxWith</a></code> but uses a default catchall fold to handle inputs which
 do not have a specific fold in the map to handle them.</p><p>If any fold in the map stops, inputs meant for that fold are sent to the
 catchall fold. If the catchall fold stops then inputs that do not match any
 fold are ignored.</p><p>Stops when all the folds, including the catchall fold, stop.</p><p><em>Internal</em></p></div></div><a href="#g:21" id="g:21"><h1>Classifying</h1></a><div class="top"><p class="src"><a id="v:classify" class="def">classify</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (k, a) (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b) <a href="src/Streamly.Internal.Data.Fold.html#classify" class="link">Source</a> <a href="#v:classify" class="selflink">#</a></p><div class="doc"><p>Given an input stream of key value pairs and a fold for values, fold all
 the values belonging to each key.  Useful for map/reduce, bucketizing the
 input in different bins or for generating histograms.</p><pre>&gt; let input = S.fromList [(&quot;ONE&quot;,1),(&quot;ONE&quot;,1.1),(&quot;TWO&quot;,2), (&quot;TWO&quot;,2.2)]
  in S.fold (FL.classify FL.toList) input
fromList [(&quot;ONE&quot;,[1.1,1.0]),(&quot;TWO&quot;,[2.2,2.0])]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:classifyWith" class="def">classifyWith</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; (a -&gt; k) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b) <a href="src/Streamly.Internal.Data.Fold.html#classifyWith" class="link">Source</a> <a href="#v:classifyWith" class="selflink">#</a></p><div class="doc"><p>Split the input stream based on a key field and fold each split using the
 given fold. Useful for map/reduce, bucketizing the input in different bins
 or for generating histograms.</p><pre>&gt; let input = S.fromList [(&quot;ONE&quot;,1),(&quot;ONE&quot;,1.1),(&quot;TWO&quot;,2), (&quot;TWO&quot;,2.2)]
  in S.fold (FL.classify FL.toList) input
fromList [(&quot;ONE&quot;,[1.1,1.0]),(&quot;TWO&quot;,[2.2,2.0])]
</pre><p>If the classifier fold stops for a particular key any further inputs in that
 bucket are ignored.</p><p><em>Stops: never</em></p><p><em>Internal</em></p></div></div><a href="#g:22" id="g:22"><h1>Unzipping</h1></a><div class="top"><p class="src"><a id="v:unzip" class="def">unzip</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m (a, b) (x, y) <a href="src/Streamly.Internal.Data.Fold.html#unzip" class="link">Source</a> <a href="#v:unzip" class="selflink">#</a></p><div class="doc"><p>Send the elements of tuples in a stream of tuples through two different
 folds.</p><pre>
                          |-------Fold m a x--------|
---------stream of (a,b)--|                         |----m (x,y)
                          |-------Fold m b y--------|

</pre><p>This is the consumer side dual of the producer side <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-List.html#v:zip" title="GHC.List">zip</a></code> operation.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:unzipWith" class="def">unzipWith</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; (b, c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y) <a href="src/Streamly.Internal.Data.Fold.html#unzipWith" class="link">Source</a> <a href="#v:unzipWith" class="selflink">#</a></p><div class="doc"><p>Split elements in the input stream into two parts using a pure splitter
 function, direct each part to a different fold and zip the results.</p><pre>unzipWith f fld1 fld2 = map f (unzip fld1 fld2)</pre><p>This fold terminates when both the input folds terminate.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:unzipWithM" class="def">unzipWithM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (b, c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y) <a href="src/Streamly.Internal.Data.Fold.html#unzipWithM" class="link">Source</a> <a href="#v:unzipWithM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold.html#v:unzipWith" title="Streamly.Internal.Data.Fold">unzipWith</a></code> but with a monadic splitter function.</p><ul><li>- <code>unzipWithM k f1 f2 = lmapM k (unzip f1 f2)</code></li></ul><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:unzipWithFstM" class="def">unzipWithFstM</a> :: (a -&gt; m (b, c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y) <a href="src/Streamly.Internal.Data.Fold.html#unzipWithFstM" class="link">Source</a> <a href="#v:unzipWithFstM" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold.html#v:unzipWithM" title="Streamly.Internal.Data.Fold">unzipWithM</a></code> but terminates when the first fold terminates.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:unzipWithMinM" class="def">unzipWithMinM</a> :: (a -&gt; m (b, c)) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b x -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m c y -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (x, y) <a href="src/Streamly.Internal.Data.Fold.html#unzipWithMinM" class="link">Source</a> <a href="#v:unzipWithMinM" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold.html#v:unzipWithM" title="Streamly.Internal.Data.Fold">unzipWithM</a></code> but terminates when any fold terminates.</p><p><em>Unimplemented</em></p></div></div><a href="#g:23" id="g:23"><h1>Nesting</h1></a><div class="top"><p class="src"><a id="v:many" class="def">many</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Types.html#many" class="link">Source</a> <a href="#v:many" class="selflink">#</a></p><div class="doc"><p>Collect zero or more applications of a fold.  <code>many collect split</code> applies
 the <code>split</code> fold repeatedly on the input stream and accumulates zero or more
 fold results using <code>collect</code>.</p><p>Stops when <code>collect</code> stops.</p><p><em>Internal</em></p><p><em>See also: Streamly.Prelude.concatMap, Streamly.Prelude.foldMany</em></p></div></div><div class="top"><p class="src"><a id="v:intervalsOf" class="def">intervalsOf</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Types.html#intervalsOf" class="link">Source</a> <a href="#v:intervalsOf" class="selflink">#</a></p><div class="doc"><p>Group the input stream into windows of n second each and then fold each
 group using the provided fold function.</p><p>For example, we can copy and distribute a stream to multiple folds where
 each fold can group the input differently e.g. by one second, one minute and
 one hour windows respectively and fold each resulting stream of folds.</p><pre>
-----Fold m a b----|-Fold n a c-|-Fold n a c-|-...-|----Fold m a c

</pre><pre>intervalsOf n split collect = many collect (takeByTime n split)</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:chunksOf" class="def">chunksOf</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Types.html#chunksOf" class="link">Source</a> <a href="#v:chunksOf" class="selflink">#</a></p><div class="doc"><p><code>chunksOf n split collect</code> repeatedly applies the <code>split</code> fold to chunks
 of <code>n</code> items in the input stream and supplies the result to the <code>collect</code>
 fold.</p><pre>chunksOf n split collect = many collect (takeLE n split)</pre><p>Stops when <code>collect</code> stops.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:chunksBetween" class="def">chunksBetween</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.html#chunksBetween" class="link">Source</a> <a href="#v:chunksBetween" class="selflink">#</a></p><div class="doc"><p>Group the input stream into groups of elements between <code>low</code> and <code>high</code>.
 Collection starts in chunks of <code>low</code> and then keeps doubling until we reach
 <code>high</code>. Each chunk is folded using the provided fold function.</p><p>This could be useful, for example, when we are folding a stream of unknown
 size to a stream of arrays and we want to minimize the number of
 allocations.</p><p>NOTE: this would be an application of &quot;many&quot; using a terminating fold.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:concatSequence" class="def">concatSequence</a> :: <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m b c -&gt; t (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.html#concatSequence" class="link">Source</a> <a href="#v:concatSequence" class="selflink">#</a></p><div class="doc"><p><code>concatSequence f t</code> applies folds from stream <code>t</code> sequentially and
 collects the results using the fold <code>f</code>.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:concatMap" class="def">concatMap</a> :: (b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c) -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Types.html#concatMap" class="link">Source</a> <a href="#v:concatMap" class="selflink">#</a></p><div class="doc"><p>Map a <code><a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a></code> returning function on the result of a <code><a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a></code>.</p><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance method <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#v:-62--62--61-" title="Control.Monad">&gt;&gt;=</a></code>. This implementation allows
 stream fusion but has quadratic complexity. This can fuse with other
 operations and can be much faster than <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance for small number
 (less than 8) of compositions.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:duplicate" class="def">duplicate</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a (<a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a> m a b) <a href="src/Streamly.Internal.Data.Fold.Types.html#duplicate" class="link">Source</a> <a href="#v:duplicate" class="selflink">#</a></p><div class="doc"><p>Modify the fold such that it returns a new <code><a href="Streamly-Internal-Data-Fold.html#t:Fold" title="Streamly.Internal.Data.Fold">Fold</a></code> instead of the output.
 If the fold was already done the returned fold would always yield the
 result. If the fold was partial, the returned fold starts from where we left
 i.e. it uses the last accumulator value as the initial value of the
 accumulator. Thus we can resume the fold later and feed it more input.</p><pre>&gt; do
    more &lt;- S.fold (FL.duplicate FL.sum) (S.enumerateFromTo 1 10)
    evenMore &lt;- S.fold (FL.duplicate more) (S.enumerateFromTo 11 20)
    S.fold evenMore (S.enumerateFromTo 21 30)
 465</pre><p><em>Since: 0.7.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>