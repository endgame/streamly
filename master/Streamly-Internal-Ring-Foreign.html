<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Ring.Foreign</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Ring.Foreign.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2019 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Ring.Foreign</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Construction</a></li><li><a href="#g:2">Modification</a></li><li><a href="#g:3">Folds</a></li><li><a href="#g:4">Fast Byte Comparisons</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Ring">Ring</a> a = <a href="#v:Ring">Ring</a> {<ul class="subs"><li><a href="#v:ringStart">ringStart</a> :: !(<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-ForeignPtr-Safe.html#t:ForeignPtr" title="Foreign.ForeignPtr.Safe">ForeignPtr</a> a)</li><li><a href="#v:ringBound">ringBound</a> :: !(<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a)</li></ul>}</li><li class="src short"><a href="#v:new">new</a> :: <span class="keyword">forall</span> a. <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a)</li><li class="src short"><a href="#v:advance">advance</a> :: <span class="keyword">forall</span> a. <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a</li><li class="src short"><a href="#v:moveBy">moveBy</a> :: <span class="keyword">forall</span> a. <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a</li><li class="src short"><a href="#v:startOf">startOf</a> :: <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a</li><li class="src short"><a href="#v:unsafeInsert">unsafeInsert</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a)</li><li class="src short"><a href="#v:unsafeFoldRing">unsafeFoldRing</a> :: <span class="keyword">forall</span> a b. <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; b</li><li class="src short"><a href="#v:unsafeFoldRingM">unsafeFoldRingM</a> :: <span class="keyword">forall</span> m a b. (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; m b</li><li class="src short"><a href="#v:unsafeFoldRingFullM">unsafeFoldRingFullM</a> :: <span class="keyword">forall</span> m a b. (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; m b</li><li class="src short"><a href="#v:unsafeFoldRingNM">unsafeFoldRingNM</a> :: <span class="keyword">forall</span> m a b. (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; m b</li><li class="src short"><a href="#v:unsafeEqArray">unsafeEqArray</a> :: <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:unsafeEqArrayN">unsafeEqArrayN</a> :: <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Ring" class="def">Ring</a> a <a href="src/Streamly.Internal.Ring.Foreign.html#Ring" class="link">Source</a> <a href="#t:Ring" class="selflink">#</a></p><div class="doc"><p>A ring buffer is a mutable array of fixed size. Initially the array is
 empty, with ringStart pointing at the start of allocated memory. We call the
 next location to be written in the ring as ringHead. Initially ringHead ==
 ringStart. When the first item is added, ringHead points to ringStart +
 sizeof item. When the buffer becomes full ringHead would wrap around to
 ringStart. When the buffer is full, ringHead always points at the oldest
 item in the ring and the newest item added always overwrites the oldest
 item.</p><p>When using it we should keep in mind that a ringBuffer is a mutable data
 structure. We should not leak out references to it for immutable use.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Ring" class="def">Ring</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:ringStart" class="def">ringStart</a> :: !(<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-ForeignPtr-Safe.html#t:ForeignPtr" title="Foreign.ForeignPtr.Safe">ForeignPtr</a> a)</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:ringBound" class="def">ringBound</a> :: !(<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a)</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div></div><a href="#g:1" id="g:1"><h1>Construction</h1></a><div class="top"><p class="src"><a id="v:new" class="def">new</a> :: <span class="keyword">forall</span> a. <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a) <a href="src/Streamly.Internal.Ring.Foreign.html#new" class="link">Source</a> <a href="#v:new" class="selflink">#</a></p><div class="doc"><p>Create a new ringbuffer and return the ring buffer and the ringHead.
 Returns the ring and the ringHead, the ringHead is same as ringStart.</p></div></div><div class="top"><p class="src"><a id="v:advance" class="def">advance</a> :: <span class="keyword">forall</span> a. <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a <a href="src/Streamly.Internal.Ring.Foreign.html#advance" class="link">Source</a> <a href="#v:advance" class="selflink">#</a></p><div class="doc"><p>Advance the ringHead by 1 item, wrap around if we hit the end of the
 array.</p></div></div><div class="top"><p class="src"><a id="v:moveBy" class="def">moveBy</a> :: <span class="keyword">forall</span> a. <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a <a href="src/Streamly.Internal.Ring.Foreign.html#moveBy" class="link">Source</a> <a href="#v:moveBy" class="selflink">#</a></p><div class="doc"><p>Move the ringHead by n items. The direction depends on the sign on whether
 n is positive or negative. Wrap around if we hit the beginning or end of the
 array.</p></div></div><div class="top"><p class="src"><a id="v:startOf" class="def">startOf</a> :: <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a <a href="src/Streamly.Internal.Ring.Foreign.html#startOf" class="link">Source</a> <a href="#v:startOf" class="selflink">#</a></p><div class="doc"><p>Get the first address of the ring as a pointer.</p></div></div><a href="#g:2" id="g:2"><h1>Modification</h1></a><div class="top"><p class="src"><a id="v:unsafeInsert" class="def">unsafeInsert</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a) <a href="src/Streamly.Internal.Ring.Foreign.html#unsafeInsert" class="link">Source</a> <a href="#v:unsafeInsert" class="selflink">#</a></p><div class="doc"><p>Insert an item at the head of the ring, when the ring is full this
 replaces the oldest item in the ring with the new item. This is unsafe
 beause ringHead supplied is not verified to be within the Ring. Also,
 the ringStart foreignPtr must be guaranteed to be alive by the caller.</p></div></div><a href="#g:3" id="g:3"><h1>Folds</h1></a><div class="top"><p class="src"><a id="v:unsafeFoldRing" class="def">unsafeFoldRing</a> :: <span class="keyword">forall</span> a b. <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; b <a href="src/Streamly.Internal.Ring.Foreign.html#unsafeFoldRing" class="link">Source</a> <a href="#v:unsafeFoldRing" class="selflink">#</a></p><div class="doc"><p>Fold the buffer starting from ringStart up to the given <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a></code> using a pure
 step function. This is useful to fold the items in the ring when the ring is
 not full. The supplied pointer is usually the end of the ring.</p><p>Unsafe because the supplied Ptr is not checked to be in range.</p></div></div><div class="top"><p class="src"><a id="v:unsafeFoldRingM" class="def">unsafeFoldRingM</a> :: <span class="keyword">forall</span> m a b. (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; m b <a href="src/Streamly.Internal.Ring.Foreign.html#unsafeFoldRingM" class="link">Source</a> <a href="#v:unsafeFoldRingM" class="selflink">#</a></p><div class="doc"><p>Like unsafeFoldRing but with a monadic step function.</p></div></div><div class="top"><p class="src"><a id="v:unsafeFoldRingFullM" class="def">unsafeFoldRingFullM</a> :: <span class="keyword">forall</span> m a b. (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; m b <a href="src/Streamly.Internal.Ring.Foreign.html#unsafeFoldRingFullM" class="link">Source</a> <a href="#v:unsafeFoldRingFullM" class="selflink">#</a></p><div class="doc"><p>Fold the entire length of a ring buffer starting at the supplied ringHead
 pointer.  Assuming the supplied ringHead pointer points to the oldest item,
 this would fold the ring starting from the oldest item to the newest item in
 the ring.</p><p>Note, this will crash on ring of 0 size.</p></div></div><div class="top"><p class="src"><a id="v:unsafeFoldRingNM" class="def">unsafeFoldRingNM</a> :: <span class="keyword">forall</span> m a b. (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; m b <a href="src/Streamly.Internal.Ring.Foreign.html#unsafeFoldRingNM" class="link">Source</a> <a href="#v:unsafeFoldRingNM" class="selflink">#</a></p><div class="doc"><p>Fold <code>Int</code> items in the ring starting at <code>Ptr a</code>.  Won't fold more
 than the length of the ring.</p><p>Note, this will crash on ring of 0 size.</p></div></div><a href="#g:4" id="g:4"><h1>Fast Byte Comparisons</h1></a><div class="top"><p class="src"><a id="v:unsafeEqArray" class="def">unsafeEqArray</a> :: <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Ring.Foreign.html#unsafeEqArray" class="link">Source</a> <a href="#v:unsafeEqArray" class="selflink">#</a></p><div class="doc"><p>Byte compare the entire length of ringBuffer with the given array,
 starting at the supplied ringHead pointer.  Returns true if the Array and
 the ringBuffer have identical contents.</p><p>This is unsafe because the ringHead Ptr is not checked to be in range. The
 supplied array must be equal to or bigger than the ringBuffer, ARRAY BOUNDS
 ARE NOT CHECKED.</p></div></div><div class="top"><p class="src"><a id="v:unsafeEqArrayN" class="def">unsafeEqArrayN</a> :: <a href="Streamly-Internal-Ring-Foreign.html#t:Ring" title="Streamly.Internal.Ring.Foreign">Ring</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-Ptr.html#t:Ptr" title="Foreign.Ptr">Ptr</a> a -&gt; <a href="Streamly-Internal-Data-Array-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Types">Array</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Ring.Foreign.html#unsafeEqArrayN" class="link">Source</a> <a href="#v:unsafeEqArrayN" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Ring-Foreign.html#v:unsafeEqArray" title="Streamly.Internal.Ring.Foreign">unsafeEqArray</a></code> but compares only N bytes instead of entire length of
 the ring buffer. This is unsafe because the ringHead Ptr is not checked to
 be in range.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>