<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Stream.SVar</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.SVar.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2017 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.SVar</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Unfold streams from SVar</a></li><li><a href="#g:2">Fold streams to SVar</a></li><li><a href="#g:3">Concurrent folds</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:fromSVar">fromSVar</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t) =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; t m a</li><li class="src short"><a href="#v:fromSVarD">fromSVarD</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> t m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamD-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamD.Type">Stream</a> m a</li><li class="src short"><a href="#v:toSVar">toSVar</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; t m a -&gt; m ()</li><li class="src short"><a href="#v:toSVarParallel">toSVarParallel</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:State" title="Streamly.Internal.Data.SVar">State</a> t m a -&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> t m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamD-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamD.Type">Stream</a> m a -&gt; m ()</li><li class="src short"><a href="#v:fromConsumer">fromConsumer</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:pushToFold">pushToFold</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:teeToSVar">teeToSVar</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:newFoldSVar">newFoldSVar</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="Streamly-Internal-Data-SVar.html#t:State" title="Streamly.Internal.Data.SVar">State</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; (t m a -&gt; m b) -&gt; m (<a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a)</li><li class="src short"><a href="#v:newFoldSVarF">newFoldSVarF</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:State" title="Streamly.Internal.Data.SVar">State</a> t m a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; m (<a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> t m a)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Unfold streams from SVar</h1></a><div class="doc"><p>Usually the SVar is used to concurrently evaluate multiple actions in a
 stream using many worker threads that push the results to the SVar and a
 single puller that pulls them from SVar generating the evaluated stream.</p><pre>                 input stream
                      |
    &lt;-----------------|&lt;--------worker
    |  exceptions     |
output stream &lt;------SVar&lt;------worker
                      |
                      |&lt;--------worker

</pre><p>The puller itself schedules the worker threads based on demand.
 Exceptions are propagated from the worker threads to the puller.</p></div><div class="top"><p class="src"><a id="v:fromSVar" class="def">fromSVar</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t) =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.SVar.html#fromSVar" class="link">Source</a> <a href="#v:fromSVar" class="selflink">#</a></p><div class="doc"><p>Generate a stream from an SVar.  An unevaluated stream can be pushed to an
 SVar using <code><a href="Streamly-Internal-Data-Stream-SVar.html#v:toSVar" title="Streamly.Internal.Data.Stream.SVar">toSVar</a></code>.  As we pull a stream from the SVar the input stream
 gets evaluated concurrently. The evaluation depends on the SVar style and
 the configuration parameters e.g. using the maxBuffer/maxThreads
 combinators.</p></div></div><div class="top"><p class="src"><a id="v:fromSVarD" class="def">fromSVarD</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> t m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamD-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamD.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.SVar.html#fromSVarD" class="link">Source</a> <a href="#v:fromSVarD" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-SVar.html#v:fromSVar" title="Streamly.Internal.Data.Stream.SVar">fromSVar</a></code> but generates a StreamD style stream instead of CPS.</p></div></div><a href="#g:2" id="g:2"><h1>Fold streams to SVar</h1></a><div class="top"><p class="src"><a id="v:toSVar" class="def">toSVar</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; t m a -&gt; m () <a href="src/Streamly.Internal.Data.Stream.SVar.html#toSVar" class="link">Source</a> <a href="#v:toSVar" class="selflink">#</a></p><div class="doc"><p>Write a stream to an <code><a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a></code> in a non-blocking manner. The stream is
 evaluated concurrently as it is read back from the SVar using <code><a href="Streamly-Internal-Data-Stream-SVar.html#v:fromSVar" title="Streamly.Internal.Data.Stream.SVar">fromSVar</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:toSVarParallel" class="def">toSVarParallel</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:State" title="Streamly.Internal.Data.SVar">State</a> t m a -&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> t m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamD-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamD.Type">Stream</a> m a -&gt; m () <a href="src/Streamly.Internal.Data.Stream.SVar.html#toSVarParallel" class="link">Source</a> <a href="#v:toSVarParallel" class="selflink">#</a></p><div class="doc"><p>Fold the supplied stream to the SVar asynchronously using Parallel
 concurrency style.
 {-<a id=" INLINE [1] toSVarParallel "></a>-}</p></div></div><a href="#g:3" id="g:3"><h1>Concurrent folds</h1></a><div class="doc"><p>To run folds concurrently, we need to decouple the fold execution from the
 stream production. We use the SVar to do that, we have a single worker
 pushing the stream elements to the SVar and on the consumer side a fold
 driver pulls the values and folds them.</p><pre>
Fold worker &lt;------SVar&lt;------input stream
    |  exceptions  |
    ---------------&gt;

</pre><p>We need a channel for pushing exceptions from the fold worker to the stream
 pusher. The stream may be pushed to multiple folds at the same time. For
 that we need one SVar per fold:</p><pre>
Fold worker &lt;------SVar&lt;---
                   |       |
Fold worker &lt;------SVar&lt;------input stream
                   |       |
Fold worker &lt;------SVar&lt;---

</pre><p>Unlike in case concurrent stream evaluation, the puller does not drive the
 scheduling and concurrent execution of the stream. The stream is simply
 pushed by the stream producer at its own rate. The fold worker just pulls it
 and folds it.</p><p>Note: If the stream pusher terminates due to an exception, we do not
 actively terminate the fold. It gets cleaned up by the GC.</p></div><div class="top"><p class="src"><a id="v:fromConsumer" class="def">fromConsumer</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.SVar.html#fromConsumer" class="link">Source</a> <a href="#v:fromConsumer" class="selflink">#</a></p><div class="doc"><p>Poll for events sent by the fold consumer to the stream pusher. The fold
 consumer can send a <a href="Stop.html">Stop</a> event or an exception. When a <a href="Stop.html">Stop</a> is received
 this function returns <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>. If an exception is recieved then it throws the
 exception.</p></div></div><div class="top"><p class="src"><a id="v:pushToFold" class="def">pushToFold</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.SVar.html#pushToFold" class="link">Source</a> <a href="#v:pushToFold" class="selflink">#</a></p><div class="doc"><p>Push values from a stream to a fold worker via an SVar. Before pushing a
 value to the SVar it polls for events received from the fold consumer.  If a
 stop event is received then it returns <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> otherwise false.  Propagates
 exceptions received from the fold consumer.</p></div></div><div class="top"><p class="src"><a id="v:teeToSVar" class="def">teeToSVar</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.SVar.html#teeToSVar" class="link">Source</a> <a href="#v:teeToSVar" class="selflink">#</a></p><div class="doc"><p>Tap a stream and send the elements to the specified SVar in addition to
 yielding them again. The SVar runs a fold consumer. Elements are tapped and
 sent to the SVar until the fold finishes. Any exceptions from the fold
 evaluation are propagated in the current thread.</p><pre>
------input stream---------output stream-----&gt;
                   /|\   |
        exceptions  |    |  input
                    |   \|/
                    ----SVar
                         |
                        Fold

</pre></div></div><div class="top"><p class="src"><a id="v:newFoldSVar" class="def">newFoldSVar</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="Streamly-Internal-Data-SVar.html#t:State" title="Streamly.Internal.Data.SVar">State</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; (t m a -&gt; m b) -&gt; m (<a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a) <a href="src/Streamly.Internal.Data.Stream.SVar.html#newFoldSVar" class="link">Source</a> <a href="#v:newFoldSVar" class="selflink">#</a></p><div class="doc"><p>Create a Fold style SVar that runs a supplied fold function as the
 consumer.  Any elements sent to the SVar are consumed by the supplied fold
 function.</p></div></div><div class="top"><p class="src"><a id="v:newFoldSVarF" class="def">newFoldSVarF</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:State" title="Streamly.Internal.Data.SVar">State</a> t m a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; m (<a href="Streamly-Internal-Data-SVar.html#t:SVar" title="Streamly.Internal.Data.SVar">SVar</a> t m a) <a href="src/Streamly.Internal.Data.Stream.SVar.html#newFoldSVarF" class="link">Source</a> <a href="#v:newFoldSVarF" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-SVar.html#v:newFoldSVar" title="Streamly.Internal.Data.Stream.SVar">newFoldSVar</a></code> except that it uses a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> instead of a fold
 function.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>