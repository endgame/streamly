<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Fold.Types</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Fold.Types.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2019 Composewell Technologies<br />(c) 2013 Gabriel Gonzalez</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Fold.Types</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Types</a></li><li><a href="#g:2">Fold constructors</a></li><li><a href="#g:3">Fold2</a></li><li><a href="#g:4">Basic Folds</a></li><li><a href="#g:5">Generators</a></li><li><a href="#g:6">Transformations</a></li><li><a href="#g:7">Distributing</a></li><li><a href="#g:8">Serial Application</a></li><li><a href="#g:9">Nested Application</a></li><li><a href="#g:10">Misc</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><h1>Stream Consumers</h1><p>We can classify stream consumers in the following categories in order of
 increasing complexity and power:</p><h2>Accumulators</h2><p>These are the simplest folds that never fail and never terminate, they
 accumulate the input values forever and can always accept new inputs (never
 terminate) and always have a valid result value.  A
 <code><a href="Streamly-Internal-Data-Fold.html#v:sum" title="Streamly.Internal.Data.Fold">sum</a></code> operation is an example of an accumulator.
 Traditional Haskell left folds like <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Foldable.html#v:foldl" title="Data.Foldable">foldl</a></code> are accumulators.</p><p>We can distribute an input stream to two or more accumulators using a <code>tee</code>
 style composition.  Accumulators cannot be applied on a stream one after the
 other, which we call a <code>serial</code> append style composition of folds. This is
 because accumulators never terminate, since the first accumulator in a
 series will never terminate, the next one will never get to run.</p><h2>Terminating Folds</h2><p>Terminating folds are accumulators that can terminate. Once a fold
 terminates it no longer accepts any more inputs.  Terminating folds can be
 used in a <code>serial</code> append style composition where one fold can be applied
 after the other on an input stream. We can apply a terminating fold
 repeatedly on an input stream, splitting the stream and consuming it in
 fragments.  Terminating folds never fail, therefore, they do not need
 backtracking.</p><p>The <code><a href="Streamly-Internal-Data-Fold.html#v:take" title="Streamly.Internal.Data.Fold">take</a></code> operation is an example of a
 terminating fold  It terminates after consuming <code>n</code> items. Coupled with an
 accumulator (e.g. sum) it can be used to split and process the stream into
 chunks of fixed size.</p><h2>Terminating Folds with Leftovers</h2><p>The next upgrade after terminating folds is terminating folds with leftover
 inputs.  Consider the example of <code>takeWhile</code> operation, it needs to inspect
 an element for termination decision. However, it does not consume the
 element on which it terminates. To implement <code>takeWhile</code> a terminating fold
 will have to implement a way to return unconsumed input to the fold driver.</p><p>Single element leftover case is the most common and its easy to implement it
 in terminating folds using a <code>Done1</code> constructor in the <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a></code> type which
 indicates that the last element was not consumed by the fold. The following
 additional operations can be implemented as terminating folds if we do that.</p><pre>takeWhile
groupBy
wordBy
</pre><p>However, it creates several complications.  The <code><a href="Streamly-Internal-Data-Fold-Types.html#v:many" title="Streamly.Internal.Data.Fold.Types">many</a></code> combinator  requires
 a <code>Partial1</code> (<code><a href="Streamly-Internal-Data-Fold-Types.html#v:Partial" title="Streamly.Internal.Data.Fold.Types">Partial</a></code> with leftover) to handle a <code>Done1</code> from the top
 level fold, for efficient implementation.  If the collecting fold in &quot;many&quot;
 returns a <code>Partial1</code> or <code>Done1</code> then what to do with all the elements that
 have been consumed?</p><p>Similarly, in distribute, if one fold consumes a value and others say its a
 leftover then what do we do?  Folds like &quot;many&quot; require the leftover to be
 fed to it again. So in a distribute operation those folds which gave a
 leftover will have to be fed the leftover while the folds that consumed will
 have to be fed the next input.  This is very complicated to implement. We
 have the same issue in backtracking parsers being used in a distribute
 operation.</p><p>To avoid these issues we want to enforce by typing that the collecting folds
 can never return a leftover. So we need a fold type without <code>Done1</code> or
 <code>Partial1</code>. This leads us to design folds to never return a leftover and the
 use cases of single leftover are transferred to parsers where we have
 general backtracking mechanism and single leftover is just a special case of
 backtracking.</p><p>This means: takeWhile, groupBy, wordBy would be implemented as parsers.
 &quot;take 0&quot; can implemented as a fold if we make initial return <code>Step</code> type.
 &quot;takeByTime&quot; can be implemented without <code>Done1</code>.</p><h2>Parsers</h2><p>The next upgrade after terminating folds with a leftover are parsers.
 Parsers are terminating folds that can fail and backtrack. Parsers can be
 composed using an <code>alternative</code> style composition where they can backtrack
 and apply another parser if one parser fails.
 <code><a href="Streamly-Internal-Data-Parser.html#v:satisfy" title="Streamly.Internal.Data.Parser">satisfy</a></code> is a simple example of a parser, it
 would succeed if the condition is satisfied and it would fail otherwise, on
 failure an alternative parser can be used on the same input.</p><h1>Types for Stream Consumers</h1><p>In streamly, there is no separate type for accumulators. Terminating folds
 are a superset of accumulators and to avoid too many types we represent both
 using the same type, <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>.</p><p>We do not club the leftovers functionality with terminating folds because of
 the reasons explained earlier. Instead combinators that require leftovers
 are implemented as the <code><a href="Streamly-Internal-Data-Parser.html#v:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> type.  This is
 a sweet spot to balance ease of use, type safety and performance.  Using
 separate Accumulator and terminating fold types would encode more
 information in types but it would make ease of use, implementation,
 maintenance effort worse. Combining Accumulator, terminating folds and
 Parser into a single <code><a href="Streamly-Internal-Data-Parser.html#v:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> type would make
 ease of use even better but type safety and performance worse.</p><p>One of the design requirements that we have placed for better ease of use
 and code reuse is that <code><a href="Streamly-Internal-Data-Parser.html#v:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> type should be
 a strict superset of the <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> type i.e. it can do everything that a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>
 can do and more. Therefore, folds can be easily upgraded to parsers and we
 can use parser combinators on folds as well when needed.</p><h1>Fold Design</h1><p>A fold is represented by a collection of &quot;initial&quot;, &quot;step&quot; and &quot;extract&quot;
 functions. The &quot;initial&quot; action generates the initial state of the fold. The
 state is internal to the fold and maintains the accumulated output. The
 &quot;step&quot; function is invoked using the current state and the next input value
 and results in a <code>Partial</code> or <code>Done</code>. A <code>Partial</code> returns the next intermediate
 state of the fold, a <code>Done</code> indicates that the fold has terminated and
 returns the final value of the accumulator.</p><p>Every <code>Partial</code> indicates that a new accumulated output is available.  The
 accumulated output can be extracted from the state at any point using
 &quot;extract&quot;. &quot;extract&quot; can never fail. A fold returns a valid output even
 without any input i.e. even if you call &quot;extract&quot; on &quot;initial&quot; state it
 provides an output. This is not true for parsers.</p><p>In general, &quot;extract&quot; is used in two cases:</p><ul><li>When the fold is used as a scan <code>extract</code> is called on the intermediate
 state every time it is yielded by the fold, the resulting value is yielded
 as a stream.</li><li>When the fold is used as a regular fold, <code>extract</code> is called once when
 we are done feeding input to the fold.</li></ul><h1>Alternate Designs</h1><p>An alternate and simpler design would be to return the intermediate output
 via <code>Partial</code> along with the state, instead of using &quot;extract&quot; on the yielded
 state and remove the extract function altogether.</p><p>This may even facilitate more efficient implementation.  Extract from the
 intermediate state after each yield may be more costly compared to the fold
 step itself yielding the output. The fold may have more efficient ways to
 retrieve the output rather than stuffing it in the state and using extract
 on the state.</p><p>However, removing extract altogether may lead to less optimal code in some
 cases because the driver of the fold needs to thread around the intermediate
 output to return it if the stream stops before the fold could <code>Done</code>.  When
 using this approach, the <code>parseMany (FL.take filesize)</code> benchmark shows a
 2x worse performance even after ensuring everything fuses.  So we keep the
 &quot;extract&quot; approach to ensure better perf in all cases.</p><p>But we could still yield both state and the output in <code>Partial</code>, the output
 can be used for the scan use case, instead of using extract. Extract would
 then be used only for the case when the stream stops before the fold
 completes.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Step">Step</a> s b<ul class="subs"><li>= <a href="#v:Partial">Partial</a> !s</li><li>| <a href="#v:Done">Done</a> !b</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Fold">Fold</a> m a b = <span class="keyword">forall</span> s. <a href="#v:Fold">Fold</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b)) (m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b)) (s -&gt; m b)</li><li class="src short"><a href="#v:mkAccum">mkAccum</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (s -&gt; a -&gt; s) -&gt; s -&gt; (s -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:mkAccum_">mkAccum_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:mkAccumM">mkAccumM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; (s -&gt; a -&gt; m s) -&gt; m s -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:mkAccumM_">mkAccumM_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:mkFold">mkFold</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (s -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b -&gt; (s -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:mkFold_">mkFold_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> b b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:mkFoldM">mkFoldM</a> :: (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b)) -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b) -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:mkFoldM_">mkFoldM_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> b b)) -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><span class="keyword">data</span> <a href="#t:Fold2">Fold2</a> m c a b = <span class="keyword">forall</span> s. <a href="#v:Fold2">Fold2</a> (s -&gt; a -&gt; m s) (c -&gt; m s) (s -&gt; m b)</li><li class="src short"><a href="#v:simplify">simplify</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m c a b -&gt; c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:toList">toList</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a [a]</li><li class="src short"><a href="#v:yield">yield</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:yieldM">yieldM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:map">map</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r</li><li class="src short"><a href="#v:lmapM">lmapM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r</li><li class="src short"><a href="#v:filter">filter</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r</li><li class="src short"><a href="#v:filterM">filterM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r</li><li class="src short"><a href="#v:lcatMaybes">lcatMaybes</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) b</li><li class="src short"><a href="#v:takeLE">takeLE</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:takeByTime">takeByTime</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</li><li class="src short"><a href="#v:teeWith">teeWith</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x c</li><li class="src short"><a href="#v:teeWithFst">teeWithFst</a> :: (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a d</li><li class="src short"><a href="#v:teeWithMin">teeWithMin</a> :: (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a d</li><li class="src short"><a href="#v:shortest">shortest</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a</li><li class="src short"><a href="#v:longest">longest</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a</li><li class="src short"><a href="#v:splitWith">splitWith</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x c</li><li class="src short"><a href="#v:split_">split_</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x b</li><li class="src short"><a href="#v:concatMap">concatMap</a> :: (b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c</li><li class="src short"><a href="#v:many">many</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c</li><li class="src short"><a href="#v:intervalsOf">intervalsOf</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c</li><li class="src short"><a href="#v:chunksOf">chunksOf</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c</li><li class="src short"><a href="#v:chunksOf2">chunksOf2</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m x b c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m x a c</li><li class="src short"><a href="#v:duplicate">duplicate</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b)</li><li class="src short"><a href="#v:initialize">initialize</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b)</li><li class="src short"><a href="#v:runStep">runStep</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b)</li><li class="src short"><span class="keyword">data</span> <a href="#t:GenericRunner">GenericRunner</a> sL sR bL bR<ul class="subs"><li>= <a href="#v:RunBoth">RunBoth</a> !sL !sR</li><li>| <a href="#v:RunLeft">RunLeft</a> !sL !bR</li><li>| <a href="#v:RunRight">RunRight</a> !bL !sR</li></ul></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Types</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Step" class="def">Step</a> s b <a href="src/Streamly.Internal.Data.Fold.Types.html#Step" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></p><div class="doc"><p>Represents the result of the <code>step</code> of a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>.  <code><a href="Streamly-Internal-Data-Fold-Types.html#v:Partial" title="Streamly.Internal.Data.Fold.Types">Partial</a></code> returns an
 intermediate state of the fold, the fold step can be called again with the
 state or the driver can use <code>extract</code> on the state to get the result out.
 <code><a href="Streamly-Internal-Data-Fold-Types.html#v:Done" title="Streamly.Internal.Data.Fold.Types">Done</a></code> returns the final result and the fold cannot be driven further.</p><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Partial" class="def">Partial</a> !s</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Done" class="def">Done</a> !b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Step">Instances</h4><details id="i:Step" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Step:Bifunctor:1"></span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bifunctor.html#t:Bifunctor" title="Data.Bifunctor">Bifunctor</a> <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a></span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-270" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></td><td class="doc"><p>A bifunctor instance on <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a></code>. <code>first</code> maps on the value held by <code><a href="Streamly-Internal-Data-Fold-Types.html#v:Partial" title="Streamly.Internal.Data.Fold.Types">Partial</a></code>
 and <code>second</code> maps on the result held by <code><a href="Streamly-Internal-Data-Fold-Types.html#v:Done" title="Streamly.Internal.Data.Fold.Types">Done</a></code>.</p><p><em>Internal</em></p></td></tr><tr><td colspan="2"><details id="i:id:Step:Bifunctor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:bimap">bimap</a> :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> b d <a href="#v:bimap" class="selflink">#</a></p><p class="src"><a href="#v:first">first</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> b c <a href="#v:first" class="selflink">#</a></p><p class="src"><a href="#v:second">second</a> :: (b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> a c <a href="#v:second" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Step:Functor:2"></span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-290" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></td><td class="doc"><p>Maps the function over the result held by <code><a href="Streamly-Internal-Data-Fold-Types.html#v:Done" title="Streamly.Internal.Data.Fold.Types">Done</a></code>.
 <code>
 fmap = <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bifunctor.html#v:second" title="Data.Bifunctor">second</a></code>
 </code></p><p><em>Internal</em></p></td></tr><tr><td colspan="2"><details id="i:id:Step:Functor:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Fold" class="def">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#Fold" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></p><div class="doc"><p>The type <code>Fold m a b</code> having constructor <code>Fold step initial extract</code>
 represents a left fold over an input stream of values of type <code>a</code> to a
 single value of type <code>b</code> in <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> <code>m</code>. The constructor is not exposed via
 exposed modules, smart constructors are provided to create folds.</p><p>The fold uses an intermediate state <code>s</code> as accumulator, the type <code>s</code> is
 specific to the fold. The initial value of the fold state <code>s</code> is returned by
 <code>initial</code>. The <code>step</code> function consumes an input and either returns the
 final result <code>b</code> if the fold is done or the next intermediate state (see
 <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a></code>). At any point the fold driver can extract the result from the
 intermediate state using the <code>extract</code> function.</p><p><em>Since: 0.7.0</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><span class="keyword">forall</span> s. <a id="v:Fold" class="def">Fold</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b)) (m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b)) (s -&gt; m b)</td><td class="doc"><p><code>Fold </code> <code> step </code> <code> initial </code> <code> extract</code></p></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Fold">Instances</h4><details id="i:Fold" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Functor:1"></span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-438" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Maps a function on the output of the fold (the type <code>b</code>).</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Functor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a a0 <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Applicative:2"></span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-544" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>The fold resulting from <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#v:-60--42--62-" title="Control.Applicative">&lt;*&gt;</a></code> distributes its input to both the argument
 folds and combines their output using the supplied function.</p><p><strong>Note:</strong> The Applicative behaviour will change in the next major release.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a a0 <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a0 -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a a0 <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Floating:3"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Numeric.html#t:Floating" title="Numeric">Floating</a> b) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Numeric.html#t:Floating" title="Numeric">Floating</a> (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-719" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Combines the fold outputs using their <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Numeric.html#t:Floating" title="Numeric">Floating</a></code> instances.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Floating:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pi">pi</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:pi" class="selflink">#</a></p><p class="src"><a href="#v:exp">exp</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:exp" class="selflink">#</a></p><p class="src"><a href="#v:log">log</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:log" class="selflink">#</a></p><p class="src"><a href="#v:sqrt">sqrt</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:sqrt" class="selflink">#</a></p><p class="src"><a href="#v:-42--42-">(**)</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:-42--42-" class="selflink">#</a></p><p class="src"><a href="#v:logBase">logBase</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:logBase" class="selflink">#</a></p><p class="src"><a href="#v:sin">sin</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:sin" class="selflink">#</a></p><p class="src"><a href="#v:cos">cos</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:cos" class="selflink">#</a></p><p class="src"><a href="#v:tan">tan</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:tan" class="selflink">#</a></p><p class="src"><a href="#v:asin">asin</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:asin" class="selflink">#</a></p><p class="src"><a href="#v:acos">acos</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:acos" class="selflink">#</a></p><p class="src"><a href="#v:atan">atan</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:atan" class="selflink">#</a></p><p class="src"><a href="#v:sinh">sinh</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:sinh" class="selflink">#</a></p><p class="src"><a href="#v:cosh">cosh</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:cosh" class="selflink">#</a></p><p class="src"><a href="#v:tanh">tanh</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:tanh" class="selflink">#</a></p><p class="src"><a href="#v:asinh">asinh</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:asinh" class="selflink">#</a></p><p class="src"><a href="#v:acosh">acosh</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:acosh" class="selflink">#</a></p><p class="src"><a href="#v:atanh">atanh</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:atanh" class="selflink">#</a></p><p class="src"><a href="#v:log1p">log1p</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:log1p" class="selflink">#</a></p><p class="src"><a href="#v:expm1">expm1</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:expm1" class="selflink">#</a></p><p class="src"><a href="#v:log1pexp">log1pexp</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:log1pexp" class="selflink">#</a></p><p class="src"><a href="#v:log1mexp">log1mexp</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:log1mexp" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Fractional:4"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> b) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-708" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Combines the fold outputs (type <code>b</code>) using their <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a></code> instances.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Fractional:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-47-">(/)</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:-47-" class="selflink">#</a></p><p class="src"><a href="#v:recip">recip</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:recip" class="selflink">#</a></p><p class="src"><a href="#v:fromRational">fromRational</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Rational" title="Prelude">Rational</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:fromRational" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Num:5"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> b) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-685" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Combines the fold outputs (type <code>b</code>) using their <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a></code> instances.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Num:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-43-">(+)</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:-43-" class="selflink">#</a></p><p class="src"><a href="#v:-45-">(-)</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:-45-" class="selflink">#</a></p><p class="src"><a href="#v:-42-">(*)</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:-42-" class="selflink">#</a></p><p class="src"><a href="#v:negate">negate</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:negate" class="selflink">#</a></p><p class="src"><a href="#v:abs">abs</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:abs" class="selflink">#</a></p><p class="src"><a href="#v:signum">signum</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:signum" class="selflink">#</a></p><p class="src"><a href="#v:fromInteger">fromInteger</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:fromInteger" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Semigroup:6"></span> (<a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> b, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-671" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Combines the outputs of the folds (the type <code>b</code>) using their <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code>
 instances.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Semigroup:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b0 =&gt; b0 -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Monoid:7"></span> (<a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> b, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> b, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b)</span> <a href="src/Streamly.Internal.Data.Fold.Types.html#line-677" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Combines the outputs of the folds (the type <code>b</code>) using their <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a></code>
 instances.</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Monoid:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b] -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:2" id="g:2"><h1>Fold constructors</h1></a><div class="top"><p class="src"><a id="v:mkAccum" class="def">mkAccum</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (s -&gt; a -&gt; s) -&gt; s -&gt; (s -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkAccum" class="link">Source</a> <a href="#v:mkAccum" class="selflink">#</a></p><div class="doc"><p>Make an accumulating (non-terminating) fold using a pure step function, a
 pure initial state and a pure state extraction function.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkAccum_" class="def">mkAccum_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkAccum_" class="link">Source</a> <a href="#v:mkAccum_" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold-Types.html#v:mkAccum" title="Streamly.Internal.Data.Fold.Types">mkAccum</a></code> but the final state extracted is identical to the
 intermediate state.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkAccumM" class="def">mkAccumM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; (s -&gt; a -&gt; m s) -&gt; m s -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkAccumM" class="link">Source</a> <a href="#v:mkAccumM" class="selflink">#</a></p><div class="doc"><p>Make an accumulating (non-terminating) fold with an effectful step
 function, an initial state, and a state extraction function.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkAccumM_" class="def">mkAccumM_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkAccumM_" class="link">Source</a> <a href="#v:mkAccumM_" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold-Types.html#v:mkAccumM" title="Streamly.Internal.Data.Fold.Types">mkAccumM</a></code> but the final state extracted is identical to the
 intermediate state.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkFold" class="def">mkFold</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (s -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b -&gt; (s -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkFold" class="link">Source</a> <a href="#v:mkFold" class="selflink">#</a></p><div class="doc"><p>Make a terminating fold using a pure step function, a pure initial state
 and a pure state extraction function.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkFold_" class="def">mkFold_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> b b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkFold_" class="link">Source</a> <a href="#v:mkFold_" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold-Types.html#v:mkFold" title="Streamly.Internal.Data.Fold.Types">mkFold</a></code> but the final state extracted is identical to the
 intermediate state.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkFoldM" class="def">mkFoldM</a> :: (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b)) -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> s b) -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkFoldM" class="link">Source</a> <a href="#v:mkFoldM" class="selflink">#</a></p><div class="doc"><p>Make a terminating fold with an effectful step function and initial state,
 and a state extraction function.</p><pre>mkFoldM = Fold</pre><p>We can just use <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> but it is provided for completeness.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mkFoldM_" class="def">mkFoldM_</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> b b)) -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Step" title="Streamly.Internal.Data.Fold.Types">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#mkFoldM_" class="link">Source</a> <a href="#v:mkFoldM_" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold-Types.html#v:mkFoldM" title="Streamly.Internal.Data.Fold.Types">mkFoldM</a></code> but the final state extracted is identical to the
 intermediate state.</p><p><em>Internal</em></p></div></div><a href="#g:3" id="g:3"><h1>Fold2</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Fold2" class="def">Fold2</a> m c a b <a href="src/Streamly.Internal.Data.Fold.Types.html#Fold2" class="link">Source</a> <a href="#t:Fold2" class="selflink">#</a></p><div class="doc"><p>Experimental type to provide a side input to the fold for generating the
 initial state. For example, if we have to fold chunks of a stream and write
 each chunk to a different file, then we can generate the file name using a
 monadic action. This is a generalized version of <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><span class="keyword">forall</span> s. <a id="v:Fold2" class="def">Fold2</a> (s -&gt; a -&gt; m s) (c -&gt; m s) (s -&gt; m b)</td><td class="doc"><p><code>Fold </code> <code> step </code> <code> inject </code> <code> extract</code></p></td></tr></table></div></div><div class="top"><p class="src"><a id="v:simplify" class="def">simplify</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m c a b -&gt; c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#simplify" class="link">Source</a> <a href="#v:simplify" class="selflink">#</a></p><div class="doc"><p>Convert more general type <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a></code> into a simpler type <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code></p></div></div><a href="#g:4" id="g:4"><h1>Basic Folds</h1></a><div class="top"><p class="src"><a id="v:toList" class="def">toList</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a [a] <a href="src/Streamly.Internal.Data.Fold.Types.html#toList" class="link">Source</a> <a href="#v:toList" class="selflink">#</a></p><div class="doc"><p>Folds the input stream to a list.</p><p><em>Warning!</em> working on large lists accumulated as buffers in memory could be
 very inefficient, consider using <a href="Streamly-Data-Array-Foreign.html">Streamly.Data.Array.Foreign</a>
 instead.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:5" id="g:5"><h1>Generators</h1></a><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><p>A fold that always yields a pure value without consuming any input.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:yieldM" class="def">yieldM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#yieldM" class="link">Source</a> <a href="#v:yieldM" class="selflink">#</a></p><div class="doc"><p>A fold that always yields the result of an effectful action without
 consuming any input.</p><p><em>Unimplemented</em></p></div></div><a href="#g:6" id="g:6"><h1>Transformations</h1></a><div class="top"><p class="src"><a id="v:map" class="def">map</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Types.html#map" class="link">Source</a> <a href="#v:map" class="selflink">#</a></p><div class="doc"><p><code>(map f fold)</code> maps the function <code>f</code> on the input of the fold.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.fold (FL.map (\x -&gt; x * x) FL.sum) (S.enumerateFromTo 1 100)
</code></strong>338350
</pre><p><strong>Note</strong>: This is not the same as <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code>. <code>map</code> is contravariant where as
 <code>fmap</code> is covariant.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:lmapM" class="def">lmapM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Types.html#lmapM" class="link">Source</a> <a href="#v:lmapM" class="selflink">#</a></p><div class="doc"><p><code>(lmapM f fold)</code> maps the monadic function <code>f</code> on the input of the fold.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:filter" class="def">filter</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Types.html#filter" class="link">Source</a> <a href="#v:filter" class="selflink">#</a></p><div class="doc"><p>Include only those elements that pass a predicate.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.fold (filter (&gt; 5) FL.sum) [1..10]
</code></strong>40
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:filterM" class="def">filterM</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Types.html#filterM" class="link">Source</a> <a href="#v:filterM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold-Types.html#v:filter" title="Streamly.Internal.Data.Fold.Types">filter</a></code> but with a monadic predicate.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:lcatMaybes" class="def">lcatMaybes</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) b <a href="src/Streamly.Internal.Data.Fold.Types.html#lcatMaybes" class="link">Source</a> <a href="#v:lcatMaybes" class="selflink">#</a></p><div class="doc"><p>Transform a fold from a pure input to a <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> input, consuming only
 <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code> values.</p></div></div><div class="top"><p class="src"><a id="v:takeLE" class="def">takeLE</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#takeLE" class="link">Source</a> <a href="#v:takeLE" class="selflink">#</a></p><div class="doc"><p>Take at most <code>n</code> input elements and fold them using the supplied fold.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold (Fold.takeLE 1 Fold.toList) $ Stream.fromList [1]
</code></strong>[1]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold (Fold.takeLE (-1) Fold.toList) $ Stream.fromList [1]
</code></strong>[]
</pre><p><em>Internal</em></p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:takeByTime" class="def">takeByTime</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Types.html#takeByTime" class="link">Source</a> <a href="#v:takeByTime" class="selflink">#</a></p><div class="doc"><p><code>takeByTime n fold</code> uses <code>fold</code> to fold the input items arriving within a
 window of first <code>n</code> seconds.</p><p>Stops when <code>fold</code> stops or when the timeout occurs.</p><p><em>Internal</em></p></div></div><a href="#g:7" id="g:7"><h1>Distributing</h1></a><div class="top"><p class="src"><a id="v:teeWith" class="def">teeWith</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x c <a href="src/Streamly.Internal.Data.Fold.Types.html#teeWith" class="link">Source</a> <a href="#v:teeWith" class="selflink">#</a></p><div class="doc"><p><code>teeWith k f1 f2</code> distributes its input to both <code>f1</code> and <code>f2</code> until both
 of them terminate and combines their output using <code>k</code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithFst" class="def">teeWithFst</a> :: (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a d <a href="src/Streamly.Internal.Data.Fold.Types.html#teeWithFst" class="link">Source</a> <a href="#v:teeWithFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold-Types.html#v:teeWith" title="Streamly.Internal.Data.Fold.Types">teeWith</a></code> but terminates when the first fold terminates.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithMin" class="def">teeWithMin</a> :: (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a d <a href="src/Streamly.Internal.Data.Fold.Types.html#teeWithMin" class="link">Source</a> <a href="#v:teeWithMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold-Types.html#v:teeWith" title="Streamly.Internal.Data.Fold.Types">teeWith</a></code> but terminates when any fold terminates.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:shortest" class="def">shortest</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a <a href="src/Streamly.Internal.Data.Fold.Types.html#shortest" class="link">Source</a> <a href="#v:shortest" class="selflink">#</a></p><div class="doc"><p>Shortest alternative. Apply both folds in parallel but choose the result
 from the one which consumed least input i.e. take the shortest succeeding
 fold.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:longest" class="def">longest</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a <a href="src/Streamly.Internal.Data.Fold.Types.html#longest" class="link">Source</a> <a href="#v:longest" class="selflink">#</a></p><div class="doc"><p>Longest alternative. Apply both folds in parallel but choose the result
 from the one which consumed more input i.e. take the longest succeeding
 fold.</p><p><em>Unimplemented</em></p></div></div><a href="#g:8" id="g:8"><h1>Serial Application</h1></a><div class="top"><p class="src"><a id="v:splitWith" class="def">splitWith</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x c <a href="src/Streamly.Internal.Data.Fold.Types.html#splitWith" class="link">Source</a> <a href="#v:splitWith" class="selflink">#</a></p><div class="doc"><p>Sequential fold application. Apply two folds sequentially to an input
 stream.  The input is provided to the first fold, when it is done the
 remaining input is provided to the second fold. When the second fold is done
 or if the input stream is over, the outputs of the two folds are combined
 using the supplied function.</p><p>Note: This is a folding dual of appending streams using
 <code><a href="Streamly-Prelude.html#v:serial" title="Streamly.Prelude">serial</a></code>, it splits the streams using two folds and zips
 the results. This has the same caveats as ParseD's <code>splitWith</code></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:split_" class="def">split_</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m x b <a href="src/Streamly.Internal.Data.Fold.Types.html#split_" class="link">Source</a> <a href="#v:split_" class="selflink">#</a></p><div class="doc"><p>Same as applicative <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#v:-42--62-" title="Control.Applicative">*&gt;</a></code>. Run two folds serially one after the other
 discarding the result of the first.</p><p><em>Unimplemented</em></p></div></div><a href="#g:9" id="g:9"><h1>Nested Application</h1></a><div class="top"><p class="src"><a id="v:concatMap" class="def">concatMap</a> :: (b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Types.html#concatMap" class="link">Source</a> <a href="#v:concatMap" class="selflink">#</a></p><div class="doc"><p>Map a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> returning function on the result of a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>.</p><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance method <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#v:-62--62--61-" title="Control.Monad">&gt;&gt;=</a></code>. This implementation allows
 stream fusion but has quadratic complexity. This can fuse with other
 operations and can be much faster than <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance for small number
 (less than 8) of compositions.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:many" class="def">many</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Types.html#many" class="link">Source</a> <a href="#v:many" class="selflink">#</a></p><div class="doc"><p>Collect zero or more applications of a fold.  <code>many collect split</code> applies
 the <code>split</code> fold repeatedly on the input stream and accumulates zero or more
 fold results using <code>collect</code>.</p><p>Stops when <code>collect</code> stops.</p><p><em>Internal</em></p><p><em>See also: Streamly.Prelude.concatMap, Streamly.Prelude.foldMany</em></p></div></div><div class="top"><p class="src"><a id="v:intervalsOf" class="def">intervalsOf</a> :: <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Types.html#intervalsOf" class="link">Source</a> <a href="#v:intervalsOf" class="selflink">#</a></p><div class="doc"><p>Group the input stream into windows of n second each and then fold each
 group using the provided fold function.</p><p>For example, we can copy and distribute a stream to multiple folds where
 each fold can group the input differently e.g. by one second, one minute and
 one hour windows respectively and fold each resulting stream of folds.</p><pre>
-----Fold m a b----|-Fold n a c-|-Fold n a c-|-...-|----Fold m a c

</pre><pre>intervalsOf n split collect = many collect (takeByTime n split)</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:chunksOf" class="def">chunksOf</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Types.html#chunksOf" class="link">Source</a> <a href="#v:chunksOf" class="selflink">#</a></p><div class="doc"><p><code>chunksOf n split collect</code> repeatedly applies the <code>split</code> fold to chunks
 of <code>n</code> items in the input stream and supplies the result to the <code>collect</code>
 fold.</p><pre>chunksOf n split collect = many collect (takeLE n split)</pre><p>Stops when <code>collect</code> stops.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:chunksOf2" class="def">chunksOf2</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m x b c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m x a c <a href="src/Streamly.Internal.Data.Fold.Types.html#chunksOf2" class="link">Source</a> <a href="#v:chunksOf2" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:duplicate" class="def">duplicate</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b) <a href="src/Streamly.Internal.Data.Fold.Types.html#duplicate" class="link">Source</a> <a href="#v:duplicate" class="selflink">#</a></p><div class="doc"><p>Modify the fold such that it returns a new <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> instead of the output.
 If the fold was already done the returned fold would always yield the
 result. If the fold was partial, the returned fold starts from where we left
 i.e. it uses the last accumulator value as the initial value of the
 accumulator. Thus we can resume the fold later and feed it more input.</p><pre>&gt; do
    more &lt;- S.fold (FL.duplicate FL.sum) (S.enumerateFromTo 1 10)
    evenMore &lt;- S.fold (FL.duplicate more) (S.enumerateFromTo 11 20)
    S.fold evenMore (S.enumerateFromTo 21 30)
 465</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:initialize" class="def">initialize</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b) <a href="src/Streamly.Internal.Data.Fold.Types.html#initialize" class="link">Source</a> <a href="#v:initialize" class="selflink">#</a></p><div class="doc"><p>Run the initialization effect of a fold. The returned fold would use the
 value returned by this effect as its initial value.</p></div></div><div class="top"><p class="src"><a id="v:runStep" class="def">runStep</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b) <a href="src/Streamly.Internal.Data.Fold.Types.html#runStep" class="link">Source</a> <a href="#v:runStep" class="selflink">#</a></p><div class="doc"><p>Run one step of a fold and store the accumulator as an initial value in
 the returned fold.</p></div></div><a href="#g:10" id="g:10"><h1>Misc</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:GenericRunner" class="def">GenericRunner</a> sL sR bL bR <a href="src/Streamly.Internal.Data.Fold.Types.html#GenericRunner" class="link">Source</a> <a href="#t:GenericRunner" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:RunBoth" class="def">RunBoth</a> !sL !sR</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:RunLeft" class="def">RunLeft</a> !sL !bR</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:RunRight" class="def">RunRight</a> !bL !sR</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>