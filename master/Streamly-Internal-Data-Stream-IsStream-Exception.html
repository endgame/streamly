<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Stream.IsStream.Exception</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.IsStream.Exception.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2019 Composewell Technologies</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.IsStream.Exception</p></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:before">before</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:after_">after_</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:after">after</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl" title="Control.Monad.Trans.Control">MonadBaseControl</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:bracket_">bracket_</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; (b -&gt; m c) -&gt; (b -&gt; t m a) -&gt; t m a</li><li class="src short"><a href="#v:bracket">bracket</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; (b -&gt; m c) -&gt; (b -&gt; t m a) -&gt; t m a</li><li class="src short"><a href="#v:onException">onException</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:finally_">finally_</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:finally">finally</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:ghandle">ghandle</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e) =&gt; (e -&gt; t m a -&gt; t m a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:handle">handle</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e) =&gt; (e -&gt; t m a) -&gt; t m a -&gt; t m a</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:before" class="def">before</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Exception.html#before" class="link">Source</a> <a href="#v:before" class="selflink">#</a></p><div class="doc"><p>Run the action <code>m b</code> before the stream yields its first element.</p><pre>before action xs = 'nilM' action &lt;&gt; xs</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:after_" class="def">after_</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Exception.html#after_" class="link">Source</a> <a href="#v:after_" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:after" title="Streamly.Internal.Data.Stream.IsStream.Exception">after</a></code>, with following differences:</p><ul><li>action <code>m b</code> won't run if the stream is garbage collected
   after partial evaluation.</li><li>Monad <code>m</code> does not require any other constraints.</li><li>has slightly better performance than <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:after" title="Streamly.Internal.Data.Stream.IsStream.Exception">after</a></code>.</li></ul><p>Same as the following, but with stream fusion:</p><pre>after_ action xs = xs &lt;&gt; 'nilM' action</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:after" class="def">after</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl" title="Control.Monad.Trans.Control">MonadBaseControl</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Exception.html#after" class="link">Source</a> <a href="#v:after" class="selflink">#</a></p><div class="doc"><p>Run the action <code>m b</code> whenever the stream <code>t m a</code> stops normally, or if it
 is garbage collected after a partial lazy evaluation.</p><p>The semantics of the action <code>m b</code> are similar to the semantics of cleanup
 action in <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:bracket" title="Streamly.Internal.Data.Stream.IsStream.Exception">bracket</a></code>.</p><p><em>See also <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:after_" title="Streamly.Internal.Data.Stream.IsStream.Exception">after_</a></code></em></p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:bracket_" class="def">bracket_</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; (b -&gt; m c) -&gt; (b -&gt; t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Exception.html#bracket_" class="link">Source</a> <a href="#v:bracket_" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:bracket" title="Streamly.Internal.Data.Stream.IsStream.Exception">bracket</a></code> but with following differences:</p><ul><li>alloc action <code>m b</code> runs with async exceptions enabled</li><li>cleanup action <code>b -&gt; m c</code> won't run if the stream is garbage collected
   after partial evaluation.</li><li>does not require a <code><a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a></code> constraint.</li><li>has slightly better performance than <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:bracket" title="Streamly.Internal.Data.Stream.IsStream.Exception">bracket</a></code>.</li></ul><p><em>Inhibits stream fusion</em></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:bracket" class="def">bracket</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; (b -&gt; m c) -&gt; (b -&gt; t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Exception.html#bracket" class="link">Source</a> <a href="#v:bracket" class="selflink">#</a></p><div class="doc"><p>Run the alloc action <code>m b</code> with async exceptions disabled but keeping
 blocking operations interruptible (see <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Exception.html#v:mask" title="Control.Exception">mask</a></code>).  Use the
 output <code>b</code> as input to <code>b -&gt; t m a</code> to generate an output stream.</p><p><code>b</code> is usually a resource under the state of monad <code>m</code>, e.g. a file
 handle, that requires a cleanup after use. The cleanup action <code>b -&gt; m c</code>,
 runs whenever the stream ends normally, due to a sync or async exception or
 if it gets garbage collected after a partial lazy evaluation.</p><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:bracket" title="Streamly.Internal.Data.Stream.IsStream.Exception">bracket</a></code> only guarantees that the cleanup action runs, and it runs with
 async exceptions enabled. The action must ensure that it can successfully
 cleanup the resource in the face of sync or async exceptions.</p><p>When the stream ends normally or on a sync exception, cleanup action runs
 immediately in the current thread context, whereas in other cases it runs in
 the GC context, therefore, cleanup may be delayed until the GC gets to run.</p><p><em>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:bracket_" title="Streamly.Internal.Data.Stream.IsStream.Exception">bracket_</a></code></em></p><p><em>Inhibits stream fusion</em></p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:onException" class="def">onException</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Exception.html#onException" class="link">Source</a> <a href="#v:onException" class="selflink">#</a></p><div class="doc"><p>Run the action <code>m b</code> if the stream aborts due to an exception. The
 exception is not caught, simply rethrown.</p><p><em>Inhibits stream fusion</em></p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:finally_" class="def">finally_</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Exception.html#finally_" class="link">Source</a> <a href="#v:finally_" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:finally" title="Streamly.Internal.Data.Stream.IsStream.Exception">finally</a></code> with following differences:</p><ul><li>action <code>m b</code> won't run if the stream is garbage collected
   after partial evaluation.</li><li>does not require a <code><a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a></code> constraint.</li><li>has slightly better performance than <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:finally" title="Streamly.Internal.Data.Stream.IsStream.Exception">finally</a></code>.</li></ul><p><em>Inhibits stream fusion</em></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:finally" class="def">finally</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Exception.html#finally" class="link">Source</a> <a href="#v:finally" class="selflink">#</a></p><div class="doc"><p>Run the action <code>m b</code> whenever the stream <code>t m a</code> stops normally, aborts
 due to an exception or if it is garbage collected after a partial lazy
 evaluation.</p><p>The semantics of running the action <code>m b</code> are similar to the cleanup action
 semantics described in <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:bracket" title="Streamly.Internal.Data.Stream.IsStream.Exception">bracket</a></code>.</p><pre>finally release = bracket (return ()) (const release)
</pre><p><em>See also <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:finally_" title="Streamly.Internal.Data.Stream.IsStream.Exception">finally_</a></code></em></p><p><em>Inhibits stream fusion</em></p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:ghandle" class="def">ghandle</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e) =&gt; (e -&gt; t m a -&gt; t m a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Exception.html#ghandle" class="link">Source</a> <a href="#v:ghandle" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:handle" title="Streamly.Internal.Data.Stream.IsStream.Exception">handle</a></code> but the exception handler is also provided with the stream
 that generated the exception as input. The exception handler can thus
 re-evaluate the stream to retry the action that failed. The exception
 handler can again call <code><a href="Streamly-Internal-Data-Stream-IsStream-Exception.html#v:ghandle" title="Streamly.Internal.Data.Stream.IsStream.Exception">ghandle</a></code> on it to retry the action multiple times.</p><p>This is highly experimental. In a stream of actions we can map the stream
 with a retry combinator to retry each action on failure.</p><p><em>Inhibits stream fusion</em></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:handle" class="def">handle</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e) =&gt; (e -&gt; t m a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Exception.html#handle" class="link">Source</a> <a href="#v:handle" class="selflink">#</a></p><div class="doc"><p>When evaluating a stream if an exception occurs, stream evaluation aborts
 and the specified exception handler is run with the exception as argument.</p><p><em>Inhibits stream fusion</em></p><p><em>Since: 0.7.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>